import { decodeFunctionResult, encodeFunctionData, } from 'viem';
import { logs } from 'named-logs';
const logger = logs('@rocketh/read-execute');
export function execute(env) {
    return async (deployment, args) => {
        const { account, ...viemArgs } = args;
        let address;
        if (account.startsWith('0x')) {
            address = account;
        }
        else {
            if (env.namedAccounts) {
                address = env.namedAccounts[account];
                if (!address) {
                    throw new Error(`no address for ${account}`);
                }
            }
            else {
                throw new Error(`no accounts setup, cannot get address for ${account}`);
            }
        }
        const artifactToUse = deployment;
        const abi = artifactToUse.abi;
        const calldata = encodeFunctionData({
            abi,
            functionName: viemArgs.functionName,
            args: viemArgs.args,
        });
        const signer = env.addressSigners[address];
        const txParam = {
            to: deployment.address,
            type: '0x2',
            from: address,
            chainId: `0x${env.network.chain.id.toString(16)}`,
            data: calldata,
            gas: viemArgs.gas && `0x${viemArgs.gas.toString(16)}`,
            // gasPrice: viemArgs.gasPrice && `0x${viemArgs.gasPrice.toString(16)}` as `0x${string}`,
            maxFeePerGas: viemArgs.maxFeePerGas ? `0x${viemArgs.maxFeePerGas.toString(16)}` : undefined,
            maxPriorityFeePerGas: viemArgs.maxPriorityFeePerGas
                ? `0x${viemArgs.maxPriorityFeePerGas.toString(16)}`
                : undefined,
            accessList: viemArgs.accessList, // TODO
            // nonce: viemArgs.nonce ? (`0x${viemArgs.nonce.toString(16)}` as `0x${string}`) : undefined,
        };
        if (viemArgs.value) {
            txParam.value = `0x${viemArgs.value?.toString(16)}`;
        }
        let txHash;
        if (signer.type === 'wallet' || signer.type === 'remote') {
            txHash = await signer.signer.request({
                method: 'eth_sendTransaction',
                params: [txParam], // TODO fix eip-1193 ?,,
            });
        }
        else {
            const rawTx = await signer.signer.request({
                method: 'eth_signTransaction',
                params: [txParam],
            });
            txHash = await env.network.provider.request({
                method: 'eth_sendRawTransaction',
                params: [rawTx],
            });
        }
        const pendingExecution = {
            type: 'execution',
            transaction: { hash: txHash, origin: address },
            // description, // TODO
            // TODO we should have the nonce, except for wallet like metamask where it is not usre you get the nonce you start with
        };
        const receipt = await env.savePendingExecution(pendingExecution);
        return receipt;
    };
}
export function executeByName(env) {
    return async (name, args) => {
        const deployment = env.getOrNull(name);
        if (!deployment) {
            throw new Error(`no deployment named ${name}`);
        }
        return execute(env)(deployment, args);
    };
}
export function read(env) {
    return async (deployment, args) => {
        const { account, ...viemArgs } = args;
        let address;
        if (account) {
            if (account.startsWith('0x')) {
                address = account;
            }
            else {
                if (env.namedAccounts) {
                    address = env.namedAccounts[account];
                    if (!address) {
                        throw new Error(`no address for ${account}`);
                    }
                }
                else {
                    throw new Error(`no accounts setup, cannot get address for ${account}`);
                }
            }
        }
        const artifactToUse = deployment;
        const abi = artifactToUse.abi;
        const calldata = encodeFunctionData({
            abi,
            functionName: viemArgs.functionName,
            args: viemArgs.args,
        });
        const result = (await env.network.provider.request({
            method: 'eth_call',
            params: [
                {
                    to: deployment.address,
                    type: '0x2',
                    from: address,
                    chainId: `0x${env.network.chain.id.toString(16)}`,
                    data: calldata,
                    // value: `0x${viemArgs.value?.toString(16)}` as `0x${string}`,
                },
            ], // TODO fix eip-1193 ?,,
        }));
        const parsed = decodeFunctionResult({
            abi,
            functionName: viemArgs.functionName,
            data: result,
            args: viemArgs.args,
        });
        return parsed;
    };
}
export function readyByName(env) {
    return async (name, args) => {
        const deployment = env.getOrNull(name);
        if (!deployment) {
            throw new Error(`no deployment named ${name}`);
        }
        return read(env)(deployment, args);
    };
}
export function tx(env) {
    return async (txData) => {
        const { account, ...viemArgs } = txData;
        let address;
        if (account.startsWith('0x')) {
            address = account;
        }
        else {
            if (env.namedAccounts) {
                address = env.namedAccounts[account];
                if (!address) {
                    throw new Error(`no address for ${account}`);
                }
            }
            else {
                throw new Error(`no accounts setup, cannot get address for ${account}`);
            }
        }
        const signer = env.addressSigners[address];
        const txParam = {
            type: '0x2',
            to: txData.to || undefined,
            from: address,
            chainId: `0x${env.network.chain.id.toString(16)}`,
            data: txData.data,
            gas: viemArgs.gas ? `0x${viemArgs.gas.toString(16)}` : undefined,
            maxFeePerGas: viemArgs.maxFeePerGas ? `0x${viemArgs.maxFeePerGas.toString(16)}` : undefined,
            maxPriorityFeePerGas: viemArgs.maxPriorityFeePerGas
                ? `0x${viemArgs.maxPriorityFeePerGas.toString(16)}`
                : undefined,
            // nonce: viemArgs.nonce ? (`0x${viemArgs.nonce.toString(16)}` as `0x${string}`) : undefined,
            accessList: viemArgs.accessList, // TODO check
        };
        if (viemArgs.value) {
            txParam.value = `0x${viemArgs.value?.toString(16)}`;
        }
        let txHash;
        if (signer.type === 'wallet' || signer.type === 'remote') {
            txHash = await signer.signer.request({
                method: 'eth_sendTransaction',
                params: [txParam], // TODO fix eip-1193 ?,,
            });
        }
        else {
            const rawTx = await signer.signer.request({
                method: 'eth_signTransaction',
                params: [txParam],
            });
            txHash = await env.network.provider.request({
                method: 'eth_sendRawTransaction',
                params: [rawTx],
            });
        }
        const pendingExecution = {
            type: 'execution',
            transaction: { hash: txHash, origin: address },
            // description, // TODO
            // TODO we should have the nonce, except for wallet like metamask where it is not usre you get the nonce you start with
        };
        await env.savePendingExecution(pendingExecution);
        return txHash;
    };
}
//# sourceMappingURL=index.js.map