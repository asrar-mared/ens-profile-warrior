import { logs } from 'named-logs';
import { encodeDeployData, encodeFunctionData, encodePacked, getCreate2Address, keccak256, parseAbi, zeroHash, } from 'viem';
const logger = logs('@rocketh/deploy');
async function broadcastTransaction(env, signer, params) {
    if (signer.type === 'wallet' || signer.type === 'remote') {
        return signer.signer.request({
            method: 'eth_sendTransaction',
            params: params, // TODO fix eip-1193 ?,
        });
    }
    else {
        const rawTx = await signer.signer.request({
            method: 'eth_signTransaction',
            params,
        });
        return env.network.provider.request({
            method: 'eth_sendRawTransaction',
            params: [rawTx],
        });
    }
}
function linkRawLibrary(bytecode, libraryName, libraryAddress) {
    const address = libraryAddress.replace('0x', '');
    let encodedLibraryName;
    if (libraryName.startsWith('$') && libraryName.endsWith('$')) {
        encodedLibraryName = libraryName.slice(1, libraryName.length - 1);
    }
    else {
        encodedLibraryName = keccak256(encodePacked(['string'], [libraryName])).slice(2, 36);
    }
    const pattern = new RegExp(`_+\\$${encodedLibraryName}\\$_+`, 'g');
    if (!pattern.exec(bytecode)) {
        throw new Error(`Can't link '${libraryName}' (${encodedLibraryName}) in \n----\n ${bytecode}\n----\n`);
    }
    return bytecode.replace(pattern, address);
}
function linkRawLibraries(bytecode, libraries) {
    for (const libName of Object.keys(libraries)) {
        const libAddress = libraries[libName];
        bytecode = linkRawLibrary(bytecode, libName, libAddress);
    }
    return bytecode;
}
function linkLibraries(artifact, libraries) {
    let bytecode = artifact.bytecode;
    if (libraries) {
        if (artifact.linkReferences) {
            for (const [fileName, fileReferences] of Object.entries(artifact.linkReferences)) {
                for (const [libName, fixups] of Object.entries(fileReferences)) {
                    const addr = libraries[libName];
                    if (addr === undefined) {
                        continue;
                    }
                    for (const fixup of fixups) {
                        bytecode =
                            bytecode.substring(0, 2 + fixup.start * 2) +
                                addr.substring(2) +
                                bytecode.substring(2 + (fixup.start + fixup.length) * 2);
                    }
                }
            }
        }
        else {
            bytecode = linkRawLibraries(bytecode, libraries);
        }
    }
    // TODO return libraries object with path name <filepath.sol>:<name> for names
    return bytecode;
}
async function getCreate2Factory(env, signer, params) {
    const deploymentInfo = env.config.network.deterministicDeployment.create2;
    if (!deploymentInfo)
        throw new Error('create2 deterministic deployment info not found');
    const factoryAddress = deploymentInfo.factory;
    const factoryDeployerAddress = deploymentInfo.deployer;
    const factoryDeploymentData = deploymentInfo.signedTx;
    const funding = BigInt(deploymentInfo.funding);
    const code = await env.network.provider.request({
        method: 'eth_getCode',
        params: [factoryAddress, 'latest'],
    });
    if (code === '0x') {
        const balanceHexString = await env.network.provider.request({
            method: 'eth_getBalance',
            params: [factoryAddress, 'latest'],
        });
        const balance = BigInt(balanceHexString);
        if (balance < funding) {
            const need = funding - balance;
            const balanceToSend = `0x${need.toString(16)}`;
            const txHash = await broadcastTransaction(env, signer, [
                {
                    type: '0x2',
                    chainId: params.chainId,
                    from: params.address,
                    to: factoryDeployerAddress,
                    value: balanceToSend,
                    gas: `0x${BigInt(21000).toString(16)}`,
                    maxFeePerGas: params.maxFeePerGas,
                    maxPriorityFeePerGas: params.maxPriorityFeePerGas,
                },
            ]);
            await env.savePendingExecution({
                type: 'execution', // TODO different type ?
                transaction: { hash: txHash, origin: params.address },
            });
        }
        const txHash = await env.network.provider.request({
            method: 'eth_sendRawTransaction',
            params: [factoryDeploymentData],
        });
        await env.savePendingExecution({
            type: 'execution', // TODO different type ?
            transaction: { hash: txHash, origin: params.address },
        });
    }
    return {
        getExpectedAddress: ({ salt, bytecode }) => getCreate2Address({
            bytecode,
            from: factoryAddress,
            salt,
        }),
        encodeData: ({ salt, bytecode }) => (salt + (bytecode.slice(2) || '')),
        factoryAddress,
    };
}
async function getCreate3Factory(env, signer, params) {
    const deploymentInfo = env.config.network.deterministicDeployment.create3;
    if (!deploymentInfo)
        throw new Error('create3 deterministic deployment info not found');
    const factoryAddress = deploymentInfo.factory;
    const factoryBytecode = deploymentInfo.bytecode;
    const proxyBytecode = deploymentInfo.proxyBytecode;
    const code = await env.network.provider.request({
        method: 'eth_getCode',
        params: [factoryAddress, 'latest'],
    });
    if (code === '0x') {
        const create2 = await getCreate2Factory(env, signer, params);
        const salt = deploymentInfo.salt || zeroHash;
        const expectedAddress = create2.getExpectedAddress({ salt, bytecode: factoryBytecode });
        if (expectedAddress.toLowerCase() !== factoryAddress.toLowerCase())
            throw new Error(`create3 factory at ${factoryAddress} is not the expected address ${expectedAddress}`);
        const txHash = await broadcastTransaction(env, signer, [
            {
                type: '0x2',
                chainId: params.chainId,
                from: params.address,
                to: create2.factoryAddress,
                data: create2.encodeData({ salt, bytecode: factoryBytecode }),
                maxFeePerGas: params.maxFeePerGas,
                maxPriorityFeePerGas: params.maxPriorityFeePerGas,
            },
        ]);
        await env.savePendingExecution({
            type: 'execution', // TODO different type ?
            transaction: { hash: txHash, origin: params.address },
        });
    }
    return {
        getExpectedAddress: ({ salt }) => {
            const namespacedSalt = keccak256(encodePacked(['address', 'bytes32'], [params.address, salt]));
            const proxyAddress = getCreate2Address({
                from: factoryAddress,
                salt: namespacedSalt,
                bytecode: proxyBytecode,
            });
            // This follows the RLP encoding rules for contract addresses created by CREATE
            // prefix ++ address ++ nonce, where:
            // prefix = 0xd6 (0xc0 + 0x16), where 0x16 is length of: 0x94 ++ address ++ 0x01
            // 0x94 = 0x80 + 0x14 (0x14 is the length of an address)
            const rlpEncodedData = encodePacked(['bytes1', 'bytes1', 'address', 'bytes1'], ['0xd6', '0x94', proxyAddress, '0x01']);
            return `0x${keccak256(rlpEncodedData).slice(26)}`;
        },
        encodeData: ({ salt, bytecode }) => encodeFunctionData({
            abi: parseAbi(['function deployDeterministic(bytes memory,bytes32) external returns (address)']),
            args: [bytecode, salt],
        }),
        factoryAddress,
    };
}
export function deploy(env) {
    return async (name, args, options) => {
        const nameToDisplay = name || '<no name>';
        const skipIfAlreadyDeployed = options && 'skipIfAlreadyDeployed' in options && options.skipIfAlreadyDeployed;
        const allwaysOverride = options && 'allwaysOverride' in options && options.allwaysOverride;
        if (allwaysOverride && skipIfAlreadyDeployed) {
            throw new Error(`conflicting options: "allwaysOverride" and "skipIfAlreadyDeployed"`);
        }
        const existingDeployment = name && env.getOrNull(name);
        if (existingDeployment && skipIfAlreadyDeployed) {
            logger.info(`deployment for ${nameToDisplay} at ${existingDeployment.address}, skipIfAlreadyDeployed: true => we skip`);
            return { ...existingDeployment, newlyDeployed: false };
        }
        const { account, artifact, ...viemArgs } = args;
        let address;
        if (account.startsWith('0x')) {
            address = account;
        }
        else {
            if (env.namedAccounts) {
                address = env.namedAccounts[account];
                if (!address) {
                    throw new Error(`no address for ${account}`);
                }
            }
            else {
                throw new Error(`no accounts setup, cannot get address for ${account}`);
            }
        }
        // TODO throw specific error if artifact not found
        const artifactToUse = artifact;
        const bytecode = linkLibraries(artifactToUse, options?.libraries);
        const abi = artifactToUse.abi;
        const argsToUse = {
            ...viemArgs,
            account,
            abi,
            bytecode,
        };
        const calldata = encodeDeployData(argsToUse); // TODO any
        const argsData = `0x${calldata.replace(bytecode, '')}`;
        if (existingDeployment) {
            logger.info(`existing deployment for ${nameToDisplay} at ${existingDeployment.address}`);
        }
        if (existingDeployment && !allwaysOverride) {
            const previousBytecode = existingDeployment.bytecode;
            const previousArgsData = existingDeployment.argsData;
            // we assume cbor encoding of hash at the end
            // TODO option to remove it, can parse metadata but would rather avoid this here
            const last2Bytes = previousBytecode.slice(-4);
            const cborLength = parseInt(last2Bytes, 16);
            const previousBytecodeWithoutCBOR = previousBytecode.slice(0, -cborLength * 2);
            const newBytecodeWithoutCBOR = bytecode.slice(0, -cborLength * 2);
            if (previousBytecodeWithoutCBOR === newBytecodeWithoutCBOR && previousArgsData === argsData) {
                return { ...existingDeployment, newlyDeployed: false };
            }
            else {
                // logger.info(`-------------- WITHOUT CBOR---------------------`);
                // logger.info(previousBytecodeWithoutCBOR);
                // logger.info(newBytecodeWithoutCBOR);
                // logger.info(`-----------------------------------`);
                // logger.info(`-------------- ARGS DATA ---------------------`);
                // logger.info(previousArgsData);
                // logger.info(argsData);
                // logger.info(`-----------------------------------`);
            }
        }
        const partialDeployment = {
            ...artifactToUse,
            argsData,
            linkedData: options?.linkedData,
        };
        const signer = env.addressSigners[address];
        const chainId = `0x${env.network.chain.id.toString(16)}`;
        const maxFeePerGas = viemArgs.maxFeePerGas && `0x${viemArgs.maxFeePerGas.toString(16)}`;
        const maxPriorityFeePerGas = viemArgs.maxPriorityFeePerGas && `0x${viemArgs.maxPriorityFeePerGas.toString(16)}`;
        const params = [
            {
                type: '0x2',
                from: address,
                chainId,
                data: calldata,
                gas: viemArgs.gas && `0x${viemArgs.gas.toString(16)}`,
                maxFeePerGas,
                maxPriorityFeePerGas,
                // gasPrice: viemArgs.gasPrice && `0x${viemArgs.gasPrice.toString(16)}` as `0x${string}`,
                // value: `0x${viemArgs.value?.toString(16)}` as `0x${string}`,
                // nonce: viemArgs.nonce && (`0x${viemArgs.nonce.toString(16)}` as `0x${string}`),
            },
        ];
        let expectedAddress = undefined;
        if (options?.deterministic) {
            const [deterministicType, salt] = (() => {
                const normalizeSalt = (salt) => typeof salt === 'string' ? `0x${salt.slice(2).padStart(64, '0')}` : zeroHash;
                if (typeof options.deterministic !== 'object')
                    return ['create2', normalizeSalt(options.deterministic)];
                if (options.deterministic.type === 'create2')
                    return ['create2', normalizeSalt(options.deterministic.salt)];
                if (options.deterministic.type === 'create3')
                    return ['create3', normalizeSalt(options.deterministic.salt)];
                throw new Error(`unknown deterministic type: ${options.deterministic.type}`);
            })();
            const bytecode = params[0].data || '0x';
            const factoryParams = { chainId, address, maxFeePerGas, maxPriorityFeePerGas };
            const create = deterministicType === 'create2'
                ? await getCreate2Factory(env, signer, factoryParams)
                : await getCreate3Factory(env, signer, factoryParams);
            expectedAddress = create.getExpectedAddress({ salt, bytecode });
            const codeAlreadyDeployed = await env.network.provider.request({
                method: 'eth_getCode',
                params: [expectedAddress, 'latest'],
            });
            if (codeAlreadyDeployed !== '0x') {
                if (deterministicType === 'create3' && codeAlreadyDeployed !== bytecode)
                    throw new Error(`code already deployed at ${expectedAddress} but is not the expected bytecode`);
                env.showMessage(`contract was already deterministically deployed at ${expectedAddress}`);
                if (name) {
                    const deployment = await env.save(name, {
                        address: expectedAddress,
                        ...partialDeployment,
                    }, { doNotCountAsNewDeployment: true });
                    return { ...deployment, newlyDeployed: false };
                }
                else {
                    return { address: expectedAddress, ...partialDeployment, newlyDeployed: false };
                }
            }
            params[0].data = create.encodeData({ salt, bytecode });
            params[0].to = create.factoryAddress;
        }
        const txHash = await broadcastTransaction(env, signer, params);
        const pendingDeployment = {
            type: 'deployment',
            expectedAddress,
            partialDeployment,
            transaction: { hash: txHash, origin: address },
            name,
            // TODO we should have the nonce, except for wallet like metamask where it is not usre you get the nonce you start with
        };
        const deployment = await env.savePendingDeployment(pendingDeployment);
        return { ...deployment, newlyDeployed: true };
    };
}
//# sourceMappingURL=index.js.map