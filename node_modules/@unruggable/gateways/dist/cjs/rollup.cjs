"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractRollup = void 0;
exports.supportsV1 = supportsV1;
exports.align = align;
class AbstractRollup {
    // allows configuration of commit and prover
    // "expand LRU cache" => prover.proofLRU.maxCached = 1_000_000
    // "disable fast lookups" => prover.fast = false
    // "keep fast cache around longer" => prover.cache.cacheMs = Infinity
    // "limit targets" => prover.maxUniqueTargets = 1
    configure;
    // block tag used for "latest" information
    latestBlockTag = 'finalized';
    // block interval for event scanning
    getLogsStepSize = 10000;
    provider1;
    provider2;
    constructor(providers) {
        this.provider1 = providers.provider1;
        this.provider2 = providers.provider2;
    }
    // default interface
    get unfinalized() {
        return false; // all rollups are finalized
    }
    async _fetchParentCommitIndex(commit) {
        return commit.index - 1n; // immediate previous
    }
    async isCommitStillValid(_commit) {
        return true; // always valid
    }
    // abstract wrappers
    async fetchParentCommitIndex(commit) {
        try {
            if (!commit.index)
                throw undefined;
            const index = await this._fetchParentCommitIndex(commit);
            if (index >= commit.index)
                throw new Error(`${index} >= ${commit.index}`);
            if (index < 0)
                throw undefined;
            return index;
        }
        catch (cause) {
            throw new Error(`no parent commit: ${commit.index}`, { cause });
        }
    }
    async fetchCommit(index) {
        try {
            const commit = await this._fetchCommit(index);
            if (commit.index != index)
                throw new Error(`${index} != ${commit.index}`);
            this.configure?.(commit);
            return commit;
        }
        catch (cause) {
            throw new Error(`invalid commit: ${index}`, { cause });
        }
    }
    // convenience
    async fetchLatestCommit() {
        return this.fetchCommit(await this.fetchLatestCommitIndex());
    }
    async fetchParentCommit(commit) {
        return this.fetchCommit(await this.fetchParentCommitIndex(commit));
    }
    async fetchRecentCommits(count) {
        if (count < 1)
            return [];
        let commit = await this.fetchLatestCommit();
        const v = [commit];
        while (v.length < count && commit.index > 0) {
            commit = await this.fetchParentCommit(commit);
            v.push(commit);
        }
        return v;
    }
    get defaultWindow() {
        // was 1 day (86400)
        // 20241116: changed 6 hours
        return this.windowFromSec(6 * 3600);
    }
}
exports.AbstractRollup = AbstractRollup;
function supportsV1(rollup) {
    return 'encodeWitnessV1' in rollup;
}
function align(index, step) {
    return step === 1 ? index : index - (index % BigInt(step));
}
