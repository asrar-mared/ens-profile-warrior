"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InteractiveRollup = void 0;
const rollup_js_1 = require("./rollup.cjs");
const utils_js_1 = require("./utils.cjs");
const contract_1 = require("ethers/contract");
const abi_1 = require("ethers/abi");
const ABI = new abi_1.Interface([
    `function latestIndex() view returns (uint256)`,
    `function commits(uint256 index) view returns ((bytes32 stateRoot, uint256 prevIndex))`,
    // setter
    `function setStateRoot(uint256 index, bytes32 stateRoot)`,
]);
class InteractiveRollup extends rollup_js_1.AbstractRollup {
    factory;
    static ABI = ABI;
    Rollup;
    constructor(providers, rollup, factory) {
        super(providers);
        this.factory = factory;
        this.latestBlockTag = utils_js_1.LATEST_BLOCK_TAG;
        this.Rollup = new contract_1.Contract(rollup, ABI, this.provider1);
    }
    async fetchLatestCommitIndex() {
        return this.Rollup.latestIndex({ blockTag: this.latestBlockTag });
    }
    async _fetchParentCommitIndex(commit) {
        const { prevIndex } = await this.Rollup.commits(commit.index);
        return prevIndex;
    }
    async _fetchCommit(index) {
        const prover = await this.factory.latest(this.provider2, index);
        return { index, prover };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['uint256', 'bytes[]', 'bytes'], [commit.index, proofSeq.proofs, proofSeq.order]);
    }
    windowFromSec(_sec) {
        throw new Error('not implemented');
    }
}
exports.InteractiveRollup = InteractiveRollup;
