"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractArbitrumRollup = void 0;
const rollup_js_1 = require("../rollup.cjs");
const utils_js_1 = require("../utils.cjs");
const contract_1 = require("ethers/contract");
class AbstractArbitrumRollup extends rollup_js_1.AbstractRollup {
    isBoLD;
    minAgeBlocks;
    Rollup;
    constructor(providers, isBoLD, config, abi, minAgeBlocks) {
        if (config.isBoLD != isBoLD)
            throw new TypeError('isBold mismatch');
        super(providers);
        this.isBoLD = isBoLD;
        this.minAgeBlocks = minAgeBlocks;
        this.Rollup = new contract_1.Contract(config.Rollup, abi, this.provider1);
    }
    get unfinalized() {
        return !!this.minAgeBlocks;
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['(bytes, bytes[], bytes)'], [[commit.encodedRollupProof, proofSeq.proofs, proofSeq.order]]);
    }
    windowFromSec(sec) {
        // finalization time is not on-chain
        // the delta between createdAtBlock is a sufficient proxy
        return Math.ceil(sec / utils_js_1.MAINNET_BLOCK_SEC); // units of L1 blocks
    }
}
exports.AbstractArbitrumRollup = AbstractArbitrumRollup;
