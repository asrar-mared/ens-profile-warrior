"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZKEVMRollup = void 0;
const rollup_js_1 = require("../rollup.cjs");
const chains_js_1 = require("../chains.cjs");
const types_js_1 = require("./types.cjs");
const contract_1 = require("ethers/contract");
const ZKEVMProver_js_1 = require("./ZKEVMProver.cjs");
const constants_1 = require("ethers/constants");
const utils_js_1 = require("../utils.cjs");
// https://hackmd.io/@4cbvqzFdRBSWMHNeI8Wbwg/Syz8PeEo0
// https://github.com/0xPolygonHermez/cdk-erigon/commit/33acc63073f16a13398ef868bb4dbdd49da720ae
// https://github.com/0xPolygonHermez/cdk-erigon/commit/33acc63073f16a13398ef868bb4dbdd49da720ae#diff-715521c7a2c24ae8e05a5c9eb0c80c348cd4ac0a1151467a4eb41d5f1a570684R1717
class ZKEVMRollup extends rollup_js_1.AbstractRollup {
    RollupManager;
    rollupID;
    // https://docs.polygon.technology/zkEVM/architecture/high-level/smart-contracts/addresses/#mainnet-contracts
    static mainnetConfig = {
        chain1: chains_js_1.CHAINS.MAINNET,
        chain2: chains_js_1.CHAINS.ZKEVM,
        RollupManager: '0x5132A183E9F3CB7C848b0AAC5Ae0c4f0491B7aB2',
    };
    // https://github.com/0xPolygonHermez/cdk-erigon/tree/zkevm#networks
    static sepoliaConfig = {
        chain1: chains_js_1.CHAINS.SEPOLIA,
        chain2: chains_js_1.CHAINS.ZKEVM_CARDONA,
        RollupManager: '0x32d33D5137a7cFFb54c5Bf8371172bcEc5f310ff',
    };
    static async create(providers, config) {
        const RollupManager = new contract_1.Contract(config.RollupManager, types_js_1.ROLLUP_ABI, providers.provider1);
        const network = await providers.provider2.getNetwork();
        const rollupID = await RollupManager.chainIDToRollupID(network.chainId);
        return new this(providers, RollupManager, rollupID);
    }
    // TODO: refactor to make this public
    constructor(providers, RollupManager, rollupID) {
        super(providers);
        this.RollupManager = RollupManager;
        this.rollupID = rollupID;
    }
    fetchLatestCommitIndex() {
        return this.RollupManager.getLastVerifiedBatch(this.rollupID, {
            blockTag: this.latestBlockTag,
        });
    }
    fetchBatchStateRoot(batchIndex) {
        return this.RollupManager.getRollupBatchNumToStateRoot(this.rollupID, batchIndex);
    }
    fetchBatchInfo(batchIndex) {
        return this.provider2.send('zkevm_getBatchByNumber', [
            (0, utils_js_1.toUnpaddedHex)(batchIndex),
        ]);
    }
    async _fetchCommit(index) {
        const [batchInfo, stateRoot] = await Promise.all([
            this.fetchBatchInfo(index),
            this.fetchBatchStateRoot(index),
        ]);
        if (stateRoot == constants_1.ZeroHash)
            throw new Error('not finalized');
        const prover = new ZKEVMProver_js_1.ZKEVMProver(this.provider2, batchInfo.number);
        return { index, prover };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['tuple(uint256, bytes[], bytes)'], [[commit.index, proofSeq.proofs, proofSeq.order]]);
    }
    windowFromSec(sec) {
        // finalization is kinda on-chain
        // sequencing time is available
        return sec;
    }
}
exports.ZKEVMRollup = ZKEVMRollup;
