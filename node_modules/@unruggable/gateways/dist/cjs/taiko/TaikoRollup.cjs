"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaikoRollup = void 0;
const rollup_js_1 = require("../rollup.cjs");
const contract_1 = require("ethers/contract");
const chains_js_1 = require("../chains.cjs");
const EthProver_js_1 = require("../eth/EthProver.cjs");
const utils_js_1 = require("../utils.cjs");
const abi_1 = require("ethers/abi");
const cached_js_1 = require("../cached.cjs");
// https://github.com/taikoxyz/taiko-mono/
// https://docs.taiko.xyz/network-reference/differences-from-ethereum
// https://status.taiko.xyz/
// https://x.com/taikoxyz/status/1923698062503051483
// https://taiko.mirror.xyz/pIchmo0E-DfSySCzL52BFbus54Z3XJEO0k0Ptqqpm_I
// https://docs.taiko.xyz/taiko-alethia-protocol/codebase-analysis/taikol1-contract
const ROLLUP_ABI = new abi_1.Interface([
    `function getConfig() view returns ((
     uint64 chainId,
     uint64 blockMaxProposals,
     uint64 blockRingBufferSize,
     uint64 maxBlocksToVerify,
     uint32 blockMaxGasLimit,
     uint96 livenessBond,
     uint8 stateRootSyncInternal,
     bool checkEOAForCalldataDA
  ))`,
    `function getLastSyncedTransition() view returns (uint64 batchId)`,
    `function getBatch(uint64 batchId) view returns ((
     bytes32 metaHash,
     uint64 lastBlockId,
     uint96 reserved3,
     uint96 livenessBond,
     uint64 batchId,
     uint64 lastBlockTimestamp,
     uint64 anchorBlockId,
     uint24 nextTransitionId,
     uint8 reserved4,
     uint24 verifiedTransitionId
  ))`,
]);
class TaikoRollup extends rollup_js_1.AbstractRollup {
    commitSpan;
    // https://docs.taiko.xyz/network-reference/mainnet-addresses
    static mainnetConfig = {
        chain1: chains_js_1.CHAINS.MAINNET,
        chain2: chains_js_1.CHAINS.TAIKO,
        TaikoL1: '0x06a9Ab27c7e2255df1815E6CC0168d7755Feb19a',
    };
    static heklaConfig = {
        chain1: chains_js_1.CHAINS.HOLESKY,
        chain2: chains_js_1.CHAINS.TAIKO_HEKLA,
        TaikoL1: '0x79C9109b764609df928d16fC4a91e9081F7e87DB',
    };
    TaikoL1;
    commitStep = new cached_js_1.CachedValue(async () => {
        const cfg = await this.TaikoL1.getConfig();
        return cfg.stateRootSyncInternal * BigInt(this.commitSpan);
    }, Infinity);
    constructor(providers, config, commitSpan = 1) {
        super(providers);
        this.commitSpan = commitSpan;
        this.TaikoL1 = new contract_1.Contract(config.TaikoL1, ROLLUP_ABI, this.provider1);
    }
    fetchLatestCommitIndex() {
        return this.TaikoL1.getLastSyncedTransition({
            blockTag: this.latestBlockTag,
        });
    }
    async _fetchParentCommitIndex(commit) {
        return commit.index - (await this.commitStep.get());
    }
    async _fetchCommit(index) {
        const batch = await this.TaikoL1.getBatch(index);
        if (!batch.verifiedTransitionId)
            throw new Error('unverified');
        const prover = new EthProver_js_1.EthProver(this.provider2, batch.lastBlockId);
        return { index, prover, tid: batch.verifiedTransitionId };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['(uint256, uint24, bytes[], bytes)'], [[commit.index, commit.tid, proofSeq.proofs, proofSeq.order]]);
    }
    windowFromSec(sec) {
        // taiko is a based rollup
        // createdAt is available onchain
        return sec;
    }
}
exports.TaikoRollup = TaikoRollup;
