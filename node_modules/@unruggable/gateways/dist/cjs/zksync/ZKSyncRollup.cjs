"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZKSyncRollup = void 0;
const ZKSyncProver_js_1 = require("./ZKSyncProver.cjs");
const types_js_1 = require("./types.cjs");
const constants_1 = require("ethers/constants");
const contract_1 = require("ethers/contract");
const chains_js_1 = require("../chains.cjs");
const rollup_js_1 = require("../rollup.cjs");
const utils_js_1 = require("../utils.cjs");
const utils_1 = require("ethers/utils");
class ZKSyncRollup extends rollup_js_1.AbstractRollup {
    // https://docs.zksync.io/build/developer-reference/era-contracts/l1-contracts
    static mainnetConfig = {
        chain1: chains_js_1.CHAINS.MAINNET,
        chain2: chains_js_1.CHAINS.ZKSYNC,
        DiamondProxy: '0x32400084c286cf3e17e7b677ea9583e60a000324',
    };
    static sepoliaConfig = {
        chain1: chains_js_1.CHAINS.SEPOLIA,
        chain2: chains_js_1.CHAINS.ZKSYNC_SEPOLIA,
        DiamondProxy: '0x9A6DE0f62Aa270A8bCB1e2610078650D539B1Ef9',
    };
    // https://docs.zero.network/main-features/system-contracts#zer%CE%B8-network
    static zeroMainnetConfig = {
        chain1: chains_js_1.CHAINS.MAINNET,
        chain2: chains_js_1.CHAINS.ZERO,
        DiamondProxy: '0xdbD849acC6bA61F461CB8A41BBaeE2D673CA02d9',
    };
    static zeroSepoliaConfig = {
        chain1: chains_js_1.CHAINS.SEPOLIA,
        chain2: chains_js_1.CHAINS.ZERO_SEPOLIA,
        DiamondProxy: '0x9A62B01fFa3bD358d03508ef60bB522ABA5d1bEb',
    };
    // https://docs.abs.xyz/how-abstract-works/architecture/components/l1-rollup-contracts#list-of-l1-rollup-contracts
    static abstractSepoliaConfig = {
        chain1: chains_js_1.CHAINS.SEPOLIA,
        chain2: chains_js_1.CHAINS.ABSTRACT_SEPOLIA,
        DiamondProxy: '0x8aD52ff836A30f063dF51A00C99518880B8b36ac',
    };
    DiamondProxy;
    constructor(providers, config) {
        super(providers);
        this.DiamondProxy = new contract_1.Contract(config.DiamondProxy, types_js_1.DIAMOND_ABI, this.provider1);
    }
    async fetchLatestCommitIndex() {
        const count = await this.DiamondProxy.getTotalBatchesExecuted({
            blockTag: this.latestBlockTag,
        });
        return count - 1n;
    }
    async _fetchCommit(index) {
        const prover = new ZKSyncProver_js_1.ZKSyncProver(this.provider2, Number(index));
        const details = await prover.fetchBatchDetails();
        if (!details.commitTxHash)
            throw new Error('no commitTxHash');
        // 20240810: this check randomly fails even though the block is finalized
        // if (details.status !== 'verified') {
        //   throw new Error(`not verified: ${details.status}`);
        // }
        const [tx, [log], l2LogsTreeRoot] = await Promise.all([
            this.provider1.getTransaction(details.commitTxHash),
            this.DiamondProxy.queryFilter(this.DiamondProxy.filters.BlockCommit(index, details.rootHash)),
            this.DiamondProxy.l2LogsRootHash(index),
        ]);
        if (!tx)
            throw new Error(`missing commit tx: ${details.commitTxHash}`);
        if (!(log instanceof contract_1.EventLog))
            throw new Error(`no BlockCommit event`);
        if (l2LogsTreeRoot === constants_1.ZeroHash)
            throw new Error('not finalized');
        // 20240909: interface was changed
        // https://github.com/matter-labs/era-contracts/commit/49868afc8590c3d09daf4d5fc73dcc31587f487d
        const batch = decodeBatches(tx.data).find((x) => x.batchNumber === index);
        if (!batch)
            throw new Error(`batch not in commit`);
        const abiEncodedBatch = utils_js_1.ABI_CODER.encode([
            'uint64', // batchNumber
            'bytes32', // batchHash
            'uint64', // indexRepeatedStorageChanges
            'uint256', // numberOfLayer1Txs
            'bytes32', // priorityOperationsHash
            'bytes32', // l2LogsTreeRoot
            'uint256', // timestamp
            'bytes32', // commitment
        ], [
            batch.batchNumber, // == index
            batch.newStateRoot, // == details.rootHash
            batch.indexRepeatedStorageChanges,
            batch.numberOfLayer1Txs,
            batch.priorityOperationsHash,
            l2LogsTreeRoot,
            batch.timestamp,
            log.args.commitment,
        ]);
        return {
            index,
            prover,
            stateRoot: details.rootHash,
            abiEncodedBatch,
        };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['(bytes, bytes[], bytes)'], [[commit.abiEncodedBatch, proofSeq.proofs, proofSeq.order]]);
    }
    windowFromSec(sec) {
        // finalization time not on-chain
        // approximately 1 batch every hour, sequential
        // https://explorer.zksync.io/batches/
        return Math.ceil(sec / 3600); // units of commit index
    }
}
exports.ZKSyncRollup = ZKSyncRollup;
// https://github.com/matter-labs/era-contracts/blob/14961f1efecac1030139c4cf0655b14135197772/l1-contracts/test/unit_tests/utils.ts#L543-L553
// https://github.com/matter-labs/era-contracts/blob/14961f1efecac1030139c4cf0655b14135197772/l1-contracts/src.ts/utils.ts#L38-L41
function decodeBatches(txData) {
    const { commitData } = types_js_1.DIAMOND_ABI.decodeFunctionData('commitBatchesSharedBridge', txData);
    const version = parseInt((0, utils_1.dataSlice)(commitData, 0, 1));
    if (version === 0) {
        const [/*stored*/ _, batches] = utils_js_1.ABI_CODER.decode([
            `(
          uint64 batchNumber,
          bytes32 batchHash,
          uint64 indexRepeatedStorageChanges,
          uint256 numberOfLayer1Txs,
          bytes32 priorityOperationsHash,
          bytes32 l2LogsTreeRoot,
          uint256 timestamp,
          bytes32 commitment
        )`,
            `(
          uint64 batchNumber,
          uint64 timestamp,
          uint64 indexRepeatedStorageChanges,
          bytes32 newStateRoot,
          uint256 numberOfLayer1Txs,
          bytes32 priorityOperationsHash,
          bytes32 bootloaderHeapInitialContentsHash,
          bytes32 eventsQueueStateHash,
          bytes systemLogs,
          bytes operatorDAInput
        )[]`,
        ], (0, utils_1.dataSlice)(commitData, 1));
        return batches;
    }
    else {
        throw new Error(`unexpected commit version: ${version}`);
    }
}
