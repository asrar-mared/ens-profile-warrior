"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthSelfRollup = void 0;
const rollup_js_1 = require("../rollup.cjs");
const utils_js_1 = require("../utils.cjs");
const EthProver_js_1 = require("./EthProver.cjs");
const rlp_js_1 = require("../rlp.cjs");
const VoidProvider_js_1 = require("../VoidProvider.cjs");
// since a provable block occurs every 12 seconds, caching isn't very effective
// to increase the likelihood of caching, increase the step
// (15 min) * (60 sec/min) / (12 sec/block) = 75 blocks
// note: blockhash() only has 256 depth
class EthSelfRollup extends rollup_js_1.AbstractRollup {
    commitStep;
    constructor(provider, commitStep = 1) {
        super({ provider1: provider, provider2: VoidProvider_js_1.VOID_PROVIDER });
        this.commitStep = commitStep;
    }
    async fetchLatestCommitIndex() {
        return (0, rollup_js_1.align)(await (0, utils_js_1.fetchBlockNumber)(this.provider1, this.latestBlockTag), this.commitStep);
    }
    async _fetchParentCommitIndex(commit) {
        return (0, rollup_js_1.align)(commit.index - 1n, this.commitStep);
    }
    async _fetchCommit(index) {
        const prover = new EthProver_js_1.EthProver(this.provider1, index);
        const blockInfo = await prover.fetchBlock();
        const rlpEncodedBlock = (0, rlp_js_1.encodeRlpBlock)(blockInfo);
        return { index, prover, rlpEncodedBlock };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['(bytes, bytes[], bytes)'], [[commit.rlpEncodedBlock, proofSeq.proofs, proofSeq.order]]);
    }
    windowFromSec(sec) {
        return Math.ceil(sec / utils_js_1.MAINNET_BLOCK_SEC); // units of blocks
    }
}
exports.EthSelfRollup = EthSelfRollup;
