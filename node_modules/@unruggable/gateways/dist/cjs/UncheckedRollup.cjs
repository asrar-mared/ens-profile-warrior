"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UncheckedRollup = exports.UncheckedProver = void 0;
const vm_js_1 = require("./vm.cjs");
const rollup_js_1 = require("./rollup.cjs");
const utils_js_1 = require("./utils.cjs");
const VoidProvider_js_1 = require("./VoidProvider.cjs");
class UncheckedProver extends vm_js_1.BlockProver {
    static latest = this._createLatest();
    isContract(target) {
        target = target.toLowerCase();
        return this.cache.get(target, async (a) => {
            const code = await this.provider.getCode(a, this.block);
            return code.length > 2;
        });
    }
    getStorage(target, slot) {
        target = target.toLowerCase();
        return this.cache.get((0, vm_js_1.makeStorageKey)(target, slot), () => {
            return (0, utils_js_1.fetchStorage)(this.provider, target, slot, this.block);
        });
    }
    async _proveNeed(need, accountRef, slotRefs) {
        if (await this.isContract(need.target)) {
            accountRef.proof = '0x01';
            const m = [...slotRefs];
            const values = await Promise.all(m.map(([slot]) => this.getStorage(need.target, slot)));
            m.forEach(([, ref], i) => (ref.proof = values[i]));
        }
    }
}
exports.UncheckedProver = UncheckedProver;
class UncheckedRollup extends rollup_js_1.AbstractRollup {
    commitStep;
    constructor(provider2, commitStep = 1) {
        super({ provider1: VoidProvider_js_1.VOID_PROVIDER, provider2 });
        this.commitStep = commitStep;
        this.latestBlockTag = utils_js_1.LATEST_BLOCK_TAG;
    }
    get unfinalized() {
        return true;
    }
    async fetchLatestCommitIndex() {
        const block = await (0, utils_js_1.fetchBlock)(this.provider2, this.latestBlockTag);
        return BigInt(block.timestamp);
    }
    async _fetchParentCommitIndex(commit) {
        const { blockNumber } = commit.prover;
        if (!blockNumber)
            return -1n;
        const block = await (0, utils_js_1.fetchBlock)(this.provider2, (0, rollup_js_1.align)(blockNumber - 1n, this.commitStep));
        return BigInt(block.timestamp);
    }
    async findVisibleBlock(t) {
        // assumes block times are unique
        let b = await (0, utils_js_1.fetchBlock)(this.provider2, this.latestBlockTag);
        if (t >= BigInt(b.timestamp))
            return b; // fast path
        let a;
        for (let depth = 16n;;) {
            let i = BigInt(b.number);
            i = i > depth ? i - depth : 0n;
            a = await (0, utils_js_1.fetchBlock)(this.provider2, i);
            if (t >= BigInt(a.timestamp))
                break;
            if (!i)
                throw new Error(`no earlier block: ${t}`);
            depth <<= 1n;
            b = a;
        }
        for (;;) {
            const ia = BigInt(a.number);
            const ib = BigInt(b.number);
            if (ia === ib)
                break;
            const ic = (ia + ib) >> 1n;
            if (ic == ia)
                return t > BigInt(a.timestamp) ? b : a;
            const c = await (0, utils_js_1.fetchBlock)(this.provider2, ic);
            if (t > BigInt(c.timestamp)) {
                a = c;
            }
            else {
                b = c;
            }
        }
        return b;
    }
    async _fetchCommit(index) {
        const block = await this.findVisibleBlock(index);
        const prover = new UncheckedProver(this.provider2, block.number);
        return { index, prover, t: BigInt(block.timestamp) };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode(['uint256', 'bytes[]', 'bytes'], [commit.t, proofSeq.proofs, proofSeq.order]);
    }
    windowFromSec(sec) {
        return sec;
    }
}
exports.UncheckedRollup = UncheckedRollup;
