"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractOPRollup = void 0;
exports.hashOutputRootProof = hashOutputRootProof;
const rollup_js_1 = require("../rollup.cjs");
const EthProver_js_1 = require("../eth/EthProver.cjs");
const constants_1 = require("ethers/constants");
const crypto_1 = require("ethers/crypto");
const utils_js_1 = require("../utils.cjs");
const OutputRootProofType = `(
  bytes32 version,
  bytes32 stateRoot,
  bytes32 messagePasserStorageRoot,
  bytes32 latestBlockhash
)`;
function outputRootProofTuple(commit) {
    return [constants_1.ZeroHash, commit.stateRoot, commit.passerRoot, commit.blockHash];
}
// same as lib/optimism/packages/contract-bedrock/src/libraries/Hashing.sol
function hashOutputRootProof(commit) {
    return (0, crypto_1.keccak256)(utils_js_1.ABI_CODER.encode([OutputRootProofType], [outputRootProofTuple(commit)]));
}
class AbstractOPRollup extends rollup_js_1.AbstractRollup {
    L2ToL1MessagePasser = '0x4200000000000000000000000000000000000016';
    async createCommit(index, block) {
        const prover = new EthProver_js_1.EthProver(this.provider2, block);
        const [{ storageHash: passerRoot }, blockInfo] = await Promise.all([
            prover.fetchProofs(this.L2ToL1MessagePasser),
            prover.fetchBlock(),
        ]);
        return {
            index,
            blockHash: blockInfo.hash,
            stateRoot: blockInfo.stateRoot,
            passerRoot,
            prover,
        };
    }
    encodeWitness(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode([`(uint256, ${OutputRootProofType}, bytes[], bytes)`], [
            [
                commit.index,
                outputRootProofTuple(commit),
                proofSeq.proofs,
                proofSeq.order,
            ],
        ]);
    }
    encodeWitnessV1(commit, proofSeq) {
        return utils_js_1.ABI_CODER.encode([`(uint256, ${OutputRootProofType})`, '(bytes, bytes[])'], [
            [commit.index, outputRootProofTuple(commit)],
            [proofSeq.accountProof, proofSeq.storageProofs],
        ]);
    }
}
exports.AbstractOPRollup = AbstractOPRollup;
