import { AbstractRollup } from './rollup.mjs';
import { ABI_CODER, LATEST_BLOCK_TAG } from './utils.mjs';
import { Contract } from 'ethers/contract';
import { Interface } from 'ethers/abi';
const ABI = new Interface([
    `function latestIndex() view returns (uint256)`,
    `function commits(uint256 index) view returns ((bytes32 stateRoot, uint256 prevIndex))`,
    // setter
    `function setStateRoot(uint256 index, bytes32 stateRoot)`,
]);
export class InteractiveRollup extends AbstractRollup {
    factory;
    static ABI = ABI;
    Rollup;
    constructor(providers, rollup, factory) {
        super(providers);
        this.factory = factory;
        this.latestBlockTag = LATEST_BLOCK_TAG;
        this.Rollup = new Contract(rollup, ABI, this.provider1);
    }
    async fetchLatestCommitIndex() {
        return this.Rollup.latestIndex({ blockTag: this.latestBlockTag });
    }
    async _fetchParentCommitIndex(commit) {
        const { prevIndex } = await this.Rollup.commits(commit.index);
        return prevIndex;
    }
    async _fetchCommit(index) {
        const prover = await this.factory.latest(this.provider2, index);
        return { index, prover };
    }
    encodeWitness(commit, proofSeq) {
        return ABI_CODER.encode(['uint256', 'bytes[]', 'bytes'], [commit.index, proofSeq.proofs, proofSeq.order]);
    }
    windowFromSec(_sec) {
        throw new Error('not implemented');
    }
}
