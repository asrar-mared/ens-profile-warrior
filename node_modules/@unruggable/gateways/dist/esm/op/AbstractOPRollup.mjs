import { AbstractRollup, } from '../rollup.mjs';
import { EthProver } from '../eth/EthProver.mjs';
import { ZeroHash } from 'ethers/constants';
import { keccak256 } from 'ethers/crypto';
import { ABI_CODER } from '../utils.mjs';
const OutputRootProofType = `(
  bytes32 version,
  bytes32 stateRoot,
  bytes32 messagePasserStorageRoot,
  bytes32 latestBlockhash
)`;
function outputRootProofTuple(commit) {
    return [ZeroHash, commit.stateRoot, commit.passerRoot, commit.blockHash];
}
// same as lib/optimism/packages/contract-bedrock/src/libraries/Hashing.sol
export function hashOutputRootProof(commit) {
    return keccak256(ABI_CODER.encode([OutputRootProofType], [outputRootProofTuple(commit)]));
}
export class AbstractOPRollup extends AbstractRollup {
    L2ToL1MessagePasser = '0x4200000000000000000000000000000000000016';
    async createCommit(index, block) {
        const prover = new EthProver(this.provider2, block);
        const [{ storageHash: passerRoot }, blockInfo] = await Promise.all([
            prover.fetchProofs(this.L2ToL1MessagePasser),
            prover.fetchBlock(),
        ]);
        return {
            index,
            blockHash: blockInfo.hash,
            stateRoot: blockInfo.stateRoot,
            passerRoot,
            prover,
        };
    }
    encodeWitness(commit, proofSeq) {
        return ABI_CODER.encode([`(uint256, ${OutputRootProofType}, bytes[], bytes)`], [
            [
                commit.index,
                outputRootProofTuple(commit),
                proofSeq.proofs,
                proofSeq.order,
            ],
        ]);
    }
    encodeWitnessV1(commit, proofSeq) {
        return ABI_CODER.encode([`(uint256, ${OutputRootProofType})`, '(bytes, bytes[])'], [
            [commit.index, outputRootProofTuple(commit)],
            [proofSeq.accountProof, proofSeq.storageProofs],
        ]);
    }
}
