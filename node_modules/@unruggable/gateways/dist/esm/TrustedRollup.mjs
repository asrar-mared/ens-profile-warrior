import { AbstractRollup } from './rollup.mjs';
import { ABI_CODER } from './utils.mjs';
import { CachedValue } from './cached.mjs';
import { VOID_PROVIDER } from './VoidProvider.mjs';
import { ZeroAddress } from 'ethers/constants';
import { computeAddress } from 'ethers/transaction';
import { solidityPackedKeccak256 } from 'ethers/hash';
export class TrustedRollup extends AbstractRollup {
    factory;
    signingKey;
    latest;
    #signed = 0n;
    constructor(provider2, factory, signingKey) {
        super({ provider1: VOID_PROVIDER, provider2 });
        this.factory = factory;
        this.signingKey = signingKey;
        this.latest = new CachedValue(async () => {
            const prover = await factory.latest(this.provider2, this.latestBlockTag);
            const stateRoot = await prover.fetchStateRoot();
            const signedAt = Math.ceil(Date.now() / 1000);
            const hash = solidityPackedKeccak256(['bytes', 'address', 'uint64', 'bytes32'], ['0x1900', ZeroAddress, signedAt, stateRoot]);
            const signature = this.signingKey.sign(hash).serialized;
            return {
                index: this.#signed++,
                prover,
                stateRoot,
                signature,
                signedAt,
            };
        }, 60000);
    }
    get signerAddress() {
        return computeAddress(this.signingKey);
    }
    get unfinalized() {
        return true;
    }
    async fetchLatestCommitIndex() {
        return (await this.latest.get()).index;
    }
    async _fetchParentCommitIndex(_commit) {
        return -1n;
    }
    async _fetchCommit(_index) {
        return this.latest.get();
    }
    encodeWitness(commit, proofSeq) {
        return ABI_CODER.encode(['(bytes,uint64,bytes32,bytes[],bytes)'], [
            [
                commit.signature,
                commit.signedAt,
                commit.stateRoot,
                proofSeq.proofs,
                proofSeq.order,
            ],
        ]);
    }
    windowFromSec(sec) {
        return sec;
    }
}
