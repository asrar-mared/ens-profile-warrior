import { AbstractRollup } from '../rollup.mjs';
import { ABI_CODER, MAINNET_BLOCK_SEC } from '../utils.mjs';
import { Contract } from 'ethers/contract';
export class AbstractArbitrumRollup extends AbstractRollup {
    isBoLD;
    minAgeBlocks;
    Rollup;
    constructor(providers, isBoLD, config, abi, minAgeBlocks) {
        if (config.isBoLD != isBoLD)
            throw new TypeError('isBold mismatch');
        super(providers);
        this.isBoLD = isBoLD;
        this.minAgeBlocks = minAgeBlocks;
        this.Rollup = new Contract(config.Rollup, abi, this.provider1);
    }
    get unfinalized() {
        return !!this.minAgeBlocks;
    }
    encodeWitness(commit, proofSeq) {
        return ABI_CODER.encode(['(bytes, bytes[], bytes)'], [[commit.encodedRollupProof, proofSeq.proofs, proofSeq.order]]);
    }
    windowFromSec(sec) {
        // finalization time is not on-chain
        // the delta between createdAtBlock is a sufficient proxy
        return Math.ceil(sec / MAINNET_BLOCK_SEC); // units of L1 blocks
    }
}
