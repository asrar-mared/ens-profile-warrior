import { BlockProver, makeStorageKey } from './vm.mjs';
import { AbstractRollup, align } from './rollup.mjs';
import { ABI_CODER, fetchBlock, fetchStorage, LATEST_BLOCK_TAG, } from './utils.mjs';
import { VOID_PROVIDER } from './VoidProvider.mjs';
export class UncheckedProver extends BlockProver {
    static latest = this._createLatest();
    isContract(target) {
        target = target.toLowerCase();
        return this.cache.get(target, async (a) => {
            const code = await this.provider.getCode(a, this.block);
            return code.length > 2;
        });
    }
    getStorage(target, slot) {
        target = target.toLowerCase();
        return this.cache.get(makeStorageKey(target, slot), () => {
            return fetchStorage(this.provider, target, slot, this.block);
        });
    }
    async _proveNeed(need, accountRef, slotRefs) {
        if (await this.isContract(need.target)) {
            accountRef.proof = '0x01';
            const m = [...slotRefs];
            const values = await Promise.all(m.map(([slot]) => this.getStorage(need.target, slot)));
            m.forEach(([, ref], i) => (ref.proof = values[i]));
        }
    }
}
export class UncheckedRollup extends AbstractRollup {
    commitStep;
    constructor(provider2, commitStep = 1) {
        super({ provider1: VOID_PROVIDER, provider2 });
        this.commitStep = commitStep;
        this.latestBlockTag = LATEST_BLOCK_TAG;
    }
    get unfinalized() {
        return true;
    }
    async fetchLatestCommitIndex() {
        const block = await fetchBlock(this.provider2, this.latestBlockTag);
        return BigInt(block.timestamp);
    }
    async _fetchParentCommitIndex(commit) {
        const { blockNumber } = commit.prover;
        if (!blockNumber)
            return -1n;
        const block = await fetchBlock(this.provider2, align(blockNumber - 1n, this.commitStep));
        return BigInt(block.timestamp);
    }
    async findVisibleBlock(t) {
        // assumes block times are unique
        let b = await fetchBlock(this.provider2, this.latestBlockTag);
        if (t >= BigInt(b.timestamp))
            return b; // fast path
        let a;
        for (let depth = 16n;;) {
            let i = BigInt(b.number);
            i = i > depth ? i - depth : 0n;
            a = await fetchBlock(this.provider2, i);
            if (t >= BigInt(a.timestamp))
                break;
            if (!i)
                throw new Error(`no earlier block: ${t}`);
            depth <<= 1n;
            b = a;
        }
        for (;;) {
            const ia = BigInt(a.number);
            const ib = BigInt(b.number);
            if (ia === ib)
                break;
            const ic = (ia + ib) >> 1n;
            if (ic == ia)
                return t > BigInt(a.timestamp) ? b : a;
            const c = await fetchBlock(this.provider2, ic);
            if (t > BigInt(c.timestamp)) {
                a = c;
            }
            else {
                b = c;
            }
        }
        return b;
    }
    async _fetchCommit(index) {
        const block = await this.findVisibleBlock(index);
        const prover = new UncheckedProver(this.provider2, block.number);
        return { index, prover, t: BigInt(block.timestamp) };
    }
    encodeWitness(commit, proofSeq) {
        return ABI_CODER.encode(['uint256', 'bytes[]', 'bytes'], [commit.t, proofSeq.proofs, proofSeq.order]);
    }
    windowFromSec(sec) {
        return sec;
    }
}
