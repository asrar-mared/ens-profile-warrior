import { Interface } from 'ethers/abi';
import { type EthersError } from 'ethers/utils';
import type { Provider, BigNumberish, HexString, HexString32, HexAddress } from './types.js';
import type { RPCEthGetBlock } from './eth/types.js';
export declare const ABI_CODER: any;
export declare const NULL_CODE_HASH: any;
export declare const EVM_BLOCKHASH_DEPTH = 256;
export declare const MAINNET_BLOCK_SEC = 12;
export declare const LATEST_BLOCK_TAG = "latest";
export declare function toUnpaddedHex(x: BigNumberish | boolean): HexString;
export declare function toPaddedHex(x: BigNumberish | boolean, width?: number): string;
export declare function withResolvers<T = void>(): {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (reason?: any) => void;
};
export declare function isBlockTag(x: BigNumberish): x is string;
export declare function fetchBlock(provider: Provider, relBlockTag?: BigNumberish): Promise<RPCEthGetBlock>;
export declare function fetchBlockFromHash(provider: Provider, blockHash: HexString32): Promise<RPCEthGetBlock>;
export declare function fetchBlockNumber(provider: Provider, relBlockTag?: BigNumberish): Promise<bigint>;
export declare function fetchBlockTag(provider: Provider, relBlockTag?: BigNumberish): Promise<string | bigint>;
export declare function fetchStorage(provider: Provider, target: HexAddress, slot: BigNumberish, relBlockTag?: BigNumberish): Promise<HexString32>;
export declare function staticCall<T>(provider: Provider, to: HexAddress, abi: Interface, fragment: string, args: any[], blockTag?: BigNumberish): Promise<T>;
export declare function isEthersError(err: unknown): err is EthersError;
export declare function isRPCError(err: any, ...code: number[]): err is EthersError;
export declare function flattenErrors(err: unknown, stringify?: typeof stringifyError): string;
declare function stringifyError(err: unknown): any;
export {};
//# sourceMappingURL=utils.d.ts.map