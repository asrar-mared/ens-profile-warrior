export declare class CachedValue<T> {
    #private;
    readonly fn: () => Promise<T>;
    cacheMs: number;
    errorMs: number;
    constructor(fn: () => Promise<T>, cacheMs?: number);
    clear(): void;
    set(value: T): void;
    get value(): Promise<T> | undefined;
    get isCached(): boolean;
    get cachedRemainingMs(): number;
    get(): Promise<T>;
    force(): Promise<T>;
}
export declare class CachedMap<K, V> {
    cacheMs: number;
    maxCached: number;
    private readonly cached;
    private readonly pending;
    private timer;
    private timer_t;
    errorMs: number;
    slopMs: number;
    constructor(cacheMs?: number, // how long to cache a resolved promise
    maxCached?: number);
    private schedule;
    get pendingSize(): number;
    get cachedSize(): number;
    get nextExpirationMs(): number;
    clear(): void;
    set(key: K, value: V | Promise<V>, ms?: number): void;
    delete(key: K): void;
    cachedRemainingMs(key: K): number;
    cachedValue(key: K): Promise<V> | undefined;
    cachedKeys(): MapIterator<K>;
    peek(key: K): Promise<V> | undefined;
    setPending(key: K, value: Promise<V>, ms?: number): Promise<V>;
    get(key: K, fn: (key: K) => Promise<V>, ms?: number): Promise<V>;
}
export declare class LRU<K, V> {
    #private;
    constructor(max?: number);
    get size(): number;
    get max(): number;
    set max(n: number);
    deleteOldest(n: number): void;
    keys(): MapIterator<K>;
    entries(): MapIterator<[K, Promise<V>]>;
    clear(): void;
    delete(key: K): void;
    setValue(key: K, value: V): void;
    setPending(key: K, promise: Promise<V>): Promise<V>;
    setFuture(key: K, promise: Promise<V>): void;
    peek(key: K): Promise<V> | undefined;
    touch(key: K): Promise<V> | undefined;
    cache(key: K, fn: (key: K) => Promise<V>): Promise<V>;
}
//# sourceMappingURL=cached.d.ts.map