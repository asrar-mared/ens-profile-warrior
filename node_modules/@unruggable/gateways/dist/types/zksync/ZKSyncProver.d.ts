import type { Provider, HexAddress, HexString, HexString32, BigNumberish, ProofSequence } from '../types.js';
import { type ZKSyncStorageProof, type RPCZKSyncL1BatchDetails, encodeProof } from './types.js';
import { AbstractProver, type Need } from '../vm.js';
export declare const ZKSYNC_ACCOUNT_CODEHASH = "0x0000000000000000000000000000000000008002";
export declare class ZKSyncProver extends AbstractProver {
    readonly batchIndex: number;
    static readonly encodeProof: typeof encodeProof;
    static latestBatchIndex(provider: Provider, relBlockTag?: BigNumberish): Promise<number>;
    static latest(provider: Provider, relBlockTag?: BigNumberish): Promise<ZKSyncProver>;
    constructor(provider: Provider, batchIndex: number);
    get context(): {
        batch: number;
    };
    get requireTargetBeforeSlot(): boolean;
    fetchBatchDetails(): Promise<Omit<RPCZKSyncL1BatchDetails, 'rootHash'> & {
        rootHash: HexString32;
    }>;
    fetchStateRoot(): Promise<string>;
    fetchTimestamp(): Promise<number>;
    isContract(target: HexAddress): Promise<boolean>;
    getStorage(target: HexAddress, slot: bigint): Promise<HexString>;
    prove(needs: Need[]): Promise<ProofSequence>;
    getAccountCodeHashProof(target: HexAddress): Promise<ZKSyncStorageProof>;
    getStorageProofs(target: HexAddress, slots: bigint[]): Promise<ZKSyncStorageProof[]>;
    fetchStorageProofs(target: HexString, slots: bigint[]): Promise<ZKSyncStorageProof[]>;
}
//# sourceMappingURL=ZKSyncProver.d.ts.map