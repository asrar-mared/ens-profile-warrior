#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var import_dotenv = require("dotenv");
var import_dotenv_expand = require("dotenv-expand");
var import_node_fs2 = __toESM(require("fs"), 1);

// src/utils.ts
var import_node_fs = __toESM(require("fs"), 1);
var import_node_path = __toESM(require("path"), 1);
function lookupFile(dir, formats, options) {
  const dirFullPath = import_node_path.default.resolve(dir);
  for (const format of formats) {
    const fullPath = import_node_path.default.join(dir, format);
    if (import_node_fs.default.existsSync(fullPath) && import_node_fs.default.statSync(fullPath).isFile()) {
      const result = (options == null ? void 0 : options.pathOnly) ? fullPath : import_node_fs.default.readFileSync(fullPath, "utf-8");
      if (!(options == null ? void 0 : options.predicate) || options.predicate(result)) {
        return result;
      }
    }
  }
  const parentDir = import_node_path.default.dirname(dirFullPath);
  const absoluteRootDir = (options == null ? void 0 : options.rootDir) ? import_node_path.default.resolve(options.rootDir) : void 0;
  if (parentDir !== dir && (!absoluteRootDir || parentDir.startsWith(absoluteRootDir))) {
    return lookupFile(parentDir, formats, options);
  }
}
function _lookupMultipleFiles(dir, formats, files, options) {
  const dirFullPath = import_node_path.default.resolve(dir);
  for (const format of formats) {
    const fullPath = import_node_path.default.join(dir, format);
    if (import_node_fs.default.existsSync(fullPath) && import_node_fs.default.statSync(fullPath).isFile()) {
      const result = (options == null ? void 0 : options.pathOnly) ? fullPath : import_node_fs.default.readFileSync(fullPath, "utf-8");
      if (!(options == null ? void 0 : options.predicate) || options.predicate(result)) {
        files.push(result);
      }
    }
  }
  const parentDir = import_node_path.default.dirname(dirFullPath);
  const absoluteRootDir = (options == null ? void 0 : options.rootDir) ? import_node_path.default.resolve(options.rootDir) : void 0;
  if (parentDir !== dir && (!absoluteRootDir || parentDir.startsWith(absoluteRootDir))) {
    _lookupMultipleFiles(parentDir, formats, files, options);
  }
}
function lookupMultipleFiles(dir, formats, options) {
  const files = [];
  _lookupMultipleFiles(dir, formats, files, options);
  return files;
}

// src/index.ts
function loadEnv(config) {
  const resolvedConfig = __spreadValues({}, config);
  let { mode: mode2, folder, useModeEnv } = resolvedConfig;
  if (!folder) {
    folder = process.env["ENV_ROOT_FOLDER"];
    if (!folder) {
      try {
        const parsed2 = (0, import_dotenv.parse)(import_node_fs2.default.readFileSync(".env", { encoding: "utf-8" }));
        Object.entries(parsed2).forEach(function([key, value]) {
          if (key === "ENV_ROOT_FOLDER") {
            folder = value;
          }
        });
      } catch (e) {
      }
      try {
        const parsed2 = (0, import_dotenv.parse)(import_node_fs2.default.readFileSync(".env.local", { encoding: "utf-8" }));
        Object.entries(parsed2).forEach(function([key, value]) {
          if (key === "ENV_ROOT_FOLDER") {
            folder = value;
          }
        });
      } catch (e) {
      }
      try {
        folder = import_node_fs2.default.readFileSync(".root.env", { encoding: "utf-8" });
      } catch (e) {
      }
    }
  }
  const env_root = folder || ".";
  if (!useModeEnv) {
    let mode_env_name2 = process.env["MODE_ENV"];
    if (!mode_env_name2) {
      try {
        const content = lookupFile(".", [".env"], { rootDir: env_root });
        if (content) {
          const parsed2 = (0, import_dotenv.parse)(content);
          Object.entries(parsed2).forEach(function([key, value]) {
            if (key === "MODE_ENV") {
              mode_env_name2 = value;
            }
          });
        }
      } catch (e) {
      }
      try {
        const content = lookupFile(".", [".env.local"], { rootDir: env_root });
        if (content) {
          const parsed2 = (0, import_dotenv.parse)(content);
          Object.entries(parsed2).forEach(function([key, value]) {
            if (key === "MODE_ENV") {
              mode_env_name2 = value;
            }
          });
        }
      } catch (e) {
      }
    }
    useModeEnv = mode_env_name2 || "MODE";
  }
  if (!mode2) {
    if (typeof useModeEnv === "string") {
      mode2 = process.env[useModeEnv];
    } else {
      for (const variable of useModeEnv) {
        mode2 = process.env[variable];
        if (mode2) {
          break;
        }
      }
    }
  }
  if (!mode2) {
    mode2 = (config == null ? void 0 : config.defaultMode) || "local";
  }
  const env = {};
  const envFiles = [
    /** default file */
    `.env`,
    /** local file */
    `.env.local`
  ];
  if (config == null ? void 0 : config.defaultEnvFile) {
    envFiles.unshift(config.defaultEnvFile);
  }
  if (mode2 && mode2 !== "local") {
    envFiles.push(
      /** mode file */
      `.env.${mode2}`,
      /** mode local file */
      `.env.${mode2}.local`
    );
  }
  const parsed = Object.fromEntries(
    envFiles.flatMap((file) => {
      const paths = lookupMultipleFiles("", [file], {
        pathOnly: true,
        rootDir: env_root
      });
      if (paths.length === 0)
        return [];
      const result = [];
      for (const path2 of paths.reverse()) {
        const newEntries = Object.entries((0, import_dotenv.parse)(import_node_fs2.default.readFileSync(path2)));
        result.push(...newEntries);
      }
      return result;
    })
  );
  (0, import_dotenv_expand.expand)({ parsed });
  for (const [key, value] of Object.entries(parsed)) {
    env[key] = value;
  }
  if (typeof useModeEnv === "string") {
    process.env[useModeEnv] = mode2;
    env[useModeEnv] = mode2;
  } else {
    for (const v of useModeEnv) {
      process.env[v] = mode2;
      env[v] = mode2;
    }
  }
  return env;
}

// src/cli.ts
var import_child_process = require("child_process");
var args = process.argv.slice(2);
function error(msg) {
  console.error(msg);
  process.exit(1);
}
var mode;
var defaultMode;
var mode_env_name;
var parse = true;
var verbose = true;
var commandArgs = [];
var command;
var useGitBranchNameAsDefaultMode = false;
for (let i = 0; i < args.length; i++) {
  const arg = args[i];
  if (!arg.startsWith("-")) {
    command = arg;
    commandArgs = args.slice(i + 1);
    break;
  } else {
    if (arg === "-m") {
      mode = args[i + 1];
      if (!mode) {
        error(`-m arg specified but no mode`);
      }
      i += 1;
    } else if (arg === "-d") {
      defaultMode = args[i + 1];
      if (!defaultMode) {
        error(`-d arg specified but no default mode`);
      }
      i += 1;
    } else if (arg === "-n") {
      mode_env_name = args[i + 1];
      if (!mode_env_name) {
        error(`-n arg specified but no env var name`);
      }
      i += 1;
    } else if (arg === "--git") {
      useGitBranchNameAsDefaultMode = true;
    } else if (arg === "-P") {
      parse = false;
    } else if (arg === "--verbose") {
      verbose = true;
    } else {
      error(`arg not recognized: ${arg}`);
    }
  }
}
if (!command) {
  error(`no command specified`);
}
if (useGitBranchNameAsDefaultMode) {
  let getGitBranch = function() {
    if (process.env.VERCEL_GIT_COMMIT_REF) {
      return process.env.VERCEL_GIT_COMMIT_REF;
    }
    if (process.env.BRANCH) {
      return process.env.BRANCH;
    }
    try {
      return (0, import_child_process.execSync)("git rev-parse --abbrev-ref HEAD", { encoding: "utf8" }).trim();
    } catch (error2) {
      console.error("Error getting Git branch:", error2.message);
      return null;
    }
  };
  getGitBranch2 = getGitBranch;
  const branchName = getGitBranch();
  if (branchName) {
    if (branchName.indexOf("/") !== -1) {
      const splitted = branchName.split("/");
      defaultMode = splitted[splitted.length - 1];
    } else {
      defaultMode = branchName;
    }
  }
}
var getGitBranch2;
for (let i = 0; i < commandArgs.length; i++) {
  const arg = commandArgs[i];
  if (arg === "@@") {
    const nextArg = commandArgs[i + 1];
    if (nextArg && nextArg != "--") {
      mode = nextArg;
    }
    commandArgs.splice(i, 2);
    i--;
    if (!mode && !defaultMode) {
      error(`error: expect to be provided a mode as last argument, or have an expliclty defined defaultMode`);
    }
  }
}
if (typeof mode === "string" && mode.length === 0) {
  error(`error: mode has been specified as argument, but it is empty`);
}
if (verbose) {
  console.log(`using defaultMode: ${defaultMode}, mode: ${mode} and use mode env name: ${mode_env_name}`);
}
loadEnv({
  defaultMode,
  mode,
  useModeEnv: mode_env_name
});
function parseArguments(commandArgs2) {
  const newArgs = commandArgs2.map((arg) => {
    const [prefix, ...list_to_parse] = arg.split("@@");
    let newArg;
    if (list_to_parse.length > 0) {
      const combined = list_to_parse.map((to_parse) => {
        const [var_name, potential_default_value, potential_suffix] = to_parse.split("@:");
        if (var_name.length === 0) {
          error(`error: this is not valid : '@@${to_parse}' please specify an ENV var name after '@@'`);
        }
        const hasSuffix = typeof potential_suffix !== "undefined";
        const suffix = hasSuffix ? potential_suffix : potential_default_value;
        const default_value = hasSuffix ? potential_default_value : void 0;
        const var_names = var_name.split(",");
        let value;
        for (const name of var_names) {
          const splitted_by_colon = name.split(":");
          const actual_name = splitted_by_colon.map((v, index) => {
            if (index % 2 == 0) {
              return v;
            } else {
              return process.env[v];
            }
          }).join("");
          value = process.env[actual_name];
          if (value) {
            break;
          }
        }
        value = value || default_value;
        if (!hasSuffix && !value) {
          error(`
error: @@${to_parse} was specified in the command but there is no env variable named ${var_name}.
To prevent this error you can provide a default value with '@@${var_name}@:<default value>@:'
An empty default can be specified with '@@${var_name}@:@:'
						`);
        }
        return value + (suffix || "");
      }).join("");
      newArg = prefix + combined;
    } else {
      newArg = arg;
    }
    if (newArg.startsWith("@=")) {
      const definition = newArg.slice(2).split("=");
      if (definition.length != 2) {
        error(`
error: defintions need exactly 2 component, env variable name and value. '@=<var name>=<value>'
					`);
      }
      const envVarName = definition[0];
      const value = definition[1];
      process.env[envVarName] = value;
      return null;
    }
    return newArg;
  }).filter((v) => !!v);
  return newArgs;
}
function parseMultipleCommands(args2) {
  let firstCommandArgs;
  let moreCommandArrays = [];
  let buffer = [];
  for (let i = 0; i < args2.length; i++) {
    const arg = args2[i];
    if (arg === "~~") {
      if (!firstCommandArgs) {
        firstCommandArgs = buffer;
      } else {
        moreCommandArrays.push(buffer);
      }
      buffer = [];
    } else {
      buffer.push(arg);
    }
  }
  if (!firstCommandArgs) {
    firstCommandArgs = args2;
  } else {
    if (buffer.length > 0) {
      for (const extra_arg of buffer) {
        firstCommandArgs.push(extra_arg);
      }
      buffer = [];
    }
  }
  const extra_commands = [];
  for (const arr of moreCommandArrays) {
    if (arr[0]) {
      extra_commands.push({
        command: arr[0],
        args: arr.slice(1)
      });
    }
  }
  return { firstCommandArgs, extra_commands };
}
if (parse) {
  const commands = parseMultipleCommands(commandArgs);
  const firstCommandArgs = parseArguments(commands.firstCommandArgs);
  try {
    if (verbose) {
      console.log(`executing (parsed): ${command} ${firstCommandArgs.join(" ")}`);
    }
    (0, import_child_process.execFileSync)(command, firstCommandArgs, { stdio: "inherit" });
    if (commands.extra_commands.length > 0) {
      let i = 0;
      for (const extra_command of commands.extra_commands) {
        const parsedArgs = parseArguments(extra_command.args || []);
        if (verbose) {
          console.log(`executing:${i} (parsed): ${extra_command.command} ${parsedArgs.join(" ")}`);
        }
        (0, import_child_process.execFileSync)(extra_command.command, parsedArgs, { stdio: "inherit" });
        i++;
      }
    }
  } catch (e) {
  }
} else {
  try {
    if (verbose) {
      console.log(`executing (no parsing): ${command} ${commandArgs.join(" ")}`);
    }
    (0, import_child_process.execFileSync)(command, commandArgs, { stdio: "inherit" });
  } catch (e) {
  }
}
//# sourceMappingURL=cli.cjs.map