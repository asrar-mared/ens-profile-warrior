{"version":3,"sources":["../src/cli.ts"],"sourcesContent":["#!/usr/bin/env node\nimport {loadEnv} from '.';\nimport {execFileSync, execSync} from 'child_process';\n\nconst args = process.argv.slice(2);\n\nfunction error(msg: string) {\n\tconsole.error(msg);\n\tprocess.exit(1);\n}\n\nlet mode: string | undefined;\nlet defaultMode: string | undefined;\nlet mode_env_name: string | undefined;\nlet parse = true;\nlet verbose = true;\n\nlet commandArgs: string[] = [];\nlet command: string | undefined;\nlet useGitBranchNameAsDefaultMode = false;\n// basic arg parsing (no long form)\nfor (let i = 0; i < args.length; i++) {\n\tconst arg = args[i];\n\tif (!arg.startsWith('-')) {\n\t\tcommand = arg;\n\t\tcommandArgs = args.slice(i + 1);\n\t\tbreak;\n\t} else {\n\t\tif (arg === '-m') {\n\t\t\tmode = args[i + 1];\n\t\t\tif (!mode) {\n\t\t\t\terror(`-m arg specified but no mode`);\n\t\t\t}\n\t\t\ti += 1;\n\t\t} else if (arg === '-d') {\n\t\t\tdefaultMode = args[i + 1];\n\t\t\tif (!defaultMode) {\n\t\t\t\terror(`-d arg specified but no default mode`);\n\t\t\t}\n\t\t\ti += 1;\n\t\t} else if (arg === '-n') {\n\t\t\tmode_env_name = args[i + 1];\n\t\t\tif (!mode_env_name) {\n\t\t\t\terror(`-n arg specified but no env var name`);\n\t\t\t}\n\t\t\ti += 1;\n\t\t} else if (arg === '--git') {\n\t\t\tuseGitBranchNameAsDefaultMode = true;\n\t\t} else if (arg === '-P') {\n\t\t\tparse = false;\n\t\t} else if (arg === '--verbose') {\n\t\t\tverbose = true;\n\t\t} else {\n\t\t\terror(`arg not recognized: ${arg}`);\n\t\t}\n\t}\n}\n\nif (!command) {\n\terror(`no command specified`);\n}\n\nif (useGitBranchNameAsDefaultMode) {\n\tfunction getGitBranch() {\n\t\t// VERCEL need this:\n\t\tif (process.env.VERCEL_GIT_COMMIT_REF) {\n\t\t\treturn process.env.VERCEL_GIT_COMMIT_REF;\n\t\t}\n\t\t// NETLIFY need this:\n\t\tif (process.env.BRANCH) {\n\t\t\treturn process.env.BRANCH;\n\t\t}\n\t\ttry {\n\t\t\treturn execSync('git rev-parse --abbrev-ref HEAD', {encoding: 'utf8'}).trim();\n\t\t} catch (error: any) {\n\t\t\tconsole.error('Error getting Git branch:', error.message);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tconst branchName = getGitBranch();\n\tif (branchName) {\n\t\tif (branchName.indexOf('/') !== -1) {\n\t\t\tconst splitted = branchName.split('/');\n\t\t\tdefaultMode = splitted[splitted.length - 1];\n\t\t} else {\n\t\t\tdefaultMode = branchName;\n\t\t}\n\t}\n}\n\n// now we process each arg in turn to find the lone @@\n// this allow executor to specify the mode via a simple arg at any position\nfor (let i = 0; i < commandArgs.length; i++) {\n\tconst arg = commandArgs[i];\n\tif (arg === '@@') {\n\t\tconst nextArg = commandArgs[i + 1];\n\t\tif (nextArg && nextArg != '--') {\n\t\t\tmode = nextArg;\n\t\t}\n\t\tcommandArgs.splice(i, 2);\n\t\ti--;\n\n\t\tif (!mode && !defaultMode) {\n\t\t\terror(`error: expect to be provided a mode as last argument, or have an expliclty defined defaultMode`);\n\t\t}\n\t}\n}\n\nif (typeof mode === 'string' && mode.length === 0) {\n\terror(`error: mode has been specified as argument, but it is empty`);\n}\n\nif (verbose) {\n\tconsole.log(`using defaultMode: ${defaultMode}, mode: ${mode} and use mode env name: ${mode_env_name}`);\n}\n\n// we are now ready to load the environment\nloadEnv({\n\tdefaultMode,\n\tmode,\n\tuseModeEnv: mode_env_name,\n});\n\nfunction parseArguments(commandArgs: string[]) {\n\tconst newArgs = commandArgs\n\t\t.map((arg) => {\n\t\t\tconst [prefix, ...list_to_parse] = arg.split('@@');\n\t\t\tlet newArg;\n\t\t\tif (list_to_parse.length > 0) {\n\t\t\t\t// if there are ny @@ we process them in turn\n\t\t\t\t// we also ensure we save the prefix (could be \"\")\n\t\t\t\t// Note that ldenv will not allow you to use @@\n\t\t\t\t// TODO allow to escape  @@\n\t\t\t\tconst combined = list_to_parse\n\t\t\t\t\t.map((to_parse) => {\n\t\t\t\t\t\t// we get the var_name as first value by splitting via '@:'\n\t\t\t\t\t\t// the rest is the default value / suffix pair\n\t\t\t\t\t\tconst [var_name, potential_default_value, potential_suffix] = to_parse.split('@:');\n\n\t\t\t\t\t\tif (var_name.length === 0) {\n\t\t\t\t\t\t\terror(`error: this is not valid : '@@${to_parse}' please specify an ENV var name after '@@'`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst hasSuffix = typeof potential_suffix !== 'undefined';\n\t\t\t\t\t\tconst suffix = hasSuffix ? potential_suffix : potential_default_value;\n\t\t\t\t\t\tconst default_value = hasSuffix ? potential_default_value : undefined;\n\n\t\t\t\t\t\t// fallback var_name is allowed, they are separated by \",\"\n\t\t\t\t\t\tconst var_names = var_name.split(',');\n\n\t\t\t\t\t\tlet value;\n\t\t\t\t\t\tfor (const name of var_names) {\n\t\t\t\t\t\t\t// each of these var_name can be composed of other env value (no recursion, just one level)\n\t\t\t\t\t\t\tconst splitted_by_colon = name.split(':');\n\t\t\t\t\t\t\t// console.log({ splitted_by_colon })\n\t\t\t\t\t\t\tconst actual_name = splitted_by_colon\n\t\t\t\t\t\t\t\t.map((v, index) => {\n\t\t\t\t\t\t\t\t\tif (index % 2 == 0) {\n\t\t\t\t\t\t\t\t\t\treturn v;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn process.env[v];\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.join('');\n\t\t\t\t\t\t\t// console.log({ actual_name })\n\t\t\t\t\t\t\tvalue = process.env[actual_name];\n\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\t// if we find one of the comma separated list matching, we exit\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue = value || default_value;\n\t\t\t\t\t\tif (!hasSuffix && !value) {\n\t\t\t\t\t\t\terror(`\nerror: @@${to_parse} was specified in the command but there is no env variable named ${var_name}.\nTo prevent this error you can provide a default value with '@@${var_name}@:<default value>@:'\nAn empty default can be specified with '@@${var_name}@:@:'\n\t\t\t\t\t\t`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// console.log({ prefix, var_name, default_value, suffix, value })\n\t\t\t\t\t\treturn value + (suffix || '');\n\t\t\t\t\t})\n\t\t\t\t\t.join('');\n\t\t\t\tnewArg = prefix + combined;\n\t\t\t} else {\n\t\t\t\tnewArg = arg;\n\t\t\t}\n\t\t\tif (newArg.startsWith('@=')) {\n\t\t\t\tconst definition = newArg.slice(2).split('=');\n\t\t\t\tif (definition.length != 2) {\n\t\t\t\t\terror(`\nerror: defintions need exactly 2 component, env variable name and value. '@=<var name>=<value>'\n\t\t\t\t\t`);\n\t\t\t\t}\n\t\t\t\tconst envVarName = definition[0];\n\t\t\t\tconst value = definition[1];\n\t\t\t\tprocess.env[envVarName] = value;\n\t\t\t\treturn null; // skip it\n\t\t\t}\n\t\t\treturn newArg;\n\t\t})\n\t\t.filter((v) => !!v) as string[];\n\treturn newArgs;\n}\n\nfunction parseMultipleCommands(args: string[]) {\n\tlet firstCommandArgs: string[] | undefined;\n\tlet moreCommandArrays: string[][] = [];\n\tlet buffer: string[] = [];\n\tfor (let i = 0; i < args.length; i++) {\n\t\tconst arg = args[i];\n\t\tif (arg === '~~') {\n\t\t\tif (!firstCommandArgs) {\n\t\t\t\tfirstCommandArgs = buffer;\n\t\t\t} else {\n\t\t\t\tmoreCommandArrays.push(buffer);\n\t\t\t}\n\t\t\tbuffer = [];\n\t\t} else {\n\t\t\tbuffer.push(arg);\n\t\t}\n\t}\n\n\tif (!firstCommandArgs) {\n\t\tfirstCommandArgs = args;\n\t} else {\n\t\tif (buffer.length > 0) {\n\t\t\t// moreCommandArrays.push(buffer);\n\t\t\tfor (const extra_arg of buffer) {\n\t\t\t\tfirstCommandArgs.push(extra_arg);\n\t\t\t}\n\t\t\tbuffer = [];\n\t\t}\n\t}\n\n\tconst extra_commands: {command: string; args: string[]}[] = [];\n\tfor (const arr of moreCommandArrays) {\n\t\tif (arr[0]) {\n\t\t\textra_commands.push({\n\t\t\t\tcommand: arr[0],\n\t\t\t\targs: arr.slice(1),\n\t\t\t});\n\t\t}\n\t}\n\n\treturn {firstCommandArgs, extra_commands};\n}\n\nif (parse) {\n\tconst commands = parseMultipleCommands(commandArgs);\n\n\t// console.log({ commands })\n\n\tconst firstCommandArgs = parseArguments(commands.firstCommandArgs);\n\ttry {\n\t\tif (verbose) {\n\t\t\tconsole.log(`executing (parsed): ${command} ${firstCommandArgs.join(' ')}`);\n\t\t}\n\t\texecFileSync(command!, firstCommandArgs, {stdio: 'inherit'});\n\t\tif (commands.extra_commands.length > 0) {\n\t\t\tlet i = 0;\n\t\t\tfor (const extra_command of commands.extra_commands) {\n\t\t\t\tconst parsedArgs = parseArguments(extra_command.args || []);\n\t\t\t\tif (verbose) {\n\t\t\t\t\tconsole.log(`executing:${i} (parsed): ${extra_command.command} ${parsedArgs.join(' ')}`);\n\t\t\t\t}\n\t\t\t\texecFileSync(extra_command.command, parsedArgs, {stdio: 'inherit'});\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t} catch {}\n} else {\n\ttry {\n\t\tif (verbose) {\n\t\t\tconsole.log(`executing (no parsing): ${command} ${commandArgs.join(' ')}`);\n\t\t}\n\t\texecFileSync(command!, commandArgs, {stdio: 'inherit'});\n\t} catch {}\n}\n"],"mappings":";;;;;;AAEA,SAAQ,cAAc,gBAAe;AAErC,IAAM,OAAO,QAAQ,KAAK,MAAM,CAAC;AAEjC,SAAS,MAAM,KAAa;AAC3B,UAAQ,MAAM,GAAG;AACjB,UAAQ,KAAK,CAAC;AACf;AAEA,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI,QAAQ;AACZ,IAAI,UAAU;AAEd,IAAI,cAAwB,CAAC;AAC7B,IAAI;AACJ,IAAI,gCAAgC;AAEpC,SAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,QAAM,MAAM,KAAK,CAAC;AAClB,MAAI,CAAC,IAAI,WAAW,GAAG,GAAG;AACzB,cAAU;AACV,kBAAc,KAAK,MAAM,IAAI,CAAC;AAC9B;AAAA,EACD,OAAO;AACN,QAAI,QAAQ,MAAM;AACjB,aAAO,KAAK,IAAI,CAAC;AACjB,UAAI,CAAC,MAAM;AACV,cAAM,8BAA8B;AAAA,MACrC;AACA,WAAK;AAAA,IACN,WAAW,QAAQ,MAAM;AACxB,oBAAc,KAAK,IAAI,CAAC;AACxB,UAAI,CAAC,aAAa;AACjB,cAAM,sCAAsC;AAAA,MAC7C;AACA,WAAK;AAAA,IACN,WAAW,QAAQ,MAAM;AACxB,sBAAgB,KAAK,IAAI,CAAC;AAC1B,UAAI,CAAC,eAAe;AACnB,cAAM,sCAAsC;AAAA,MAC7C;AACA,WAAK;AAAA,IACN,WAAW,QAAQ,SAAS;AAC3B,sCAAgC;AAAA,IACjC,WAAW,QAAQ,MAAM;AACxB,cAAQ;AAAA,IACT,WAAW,QAAQ,aAAa;AAC/B,gBAAU;AAAA,IACX,OAAO;AACN,YAAM,uBAAuB,KAAK;AAAA,IACnC;AAAA,EACD;AACD;AAEA,IAAI,CAAC,SAAS;AACb,QAAM,sBAAsB;AAC7B;AAEA,IAAI,+BAA+B;AAClC,MAAS,eAAT,WAAwB;AAEvB,QAAI,QAAQ,IAAI,uBAAuB;AACtC,aAAO,QAAQ,IAAI;AAAA,IACpB;AAEA,QAAI,QAAQ,IAAI,QAAQ;AACvB,aAAO,QAAQ,IAAI;AAAA,IACpB;AACA,QAAI;AACH,aAAO,SAAS,mCAAmC,EAAC,UAAU,OAAM,CAAC,EAAE,KAAK;AAAA,IAC7E,SAASA,QAAP;AACD,cAAQ,MAAM,6BAA6BA,OAAM,OAAO;AACxD,aAAO;AAAA,IACR;AAAA,EACD;AAfS,EAAAC,gBAAA;AAiBT,QAAM,aAAa,aAAa;AAChC,MAAI,YAAY;AACf,QAAI,WAAW,QAAQ,GAAG,MAAM,IAAI;AACnC,YAAM,WAAW,WAAW,MAAM,GAAG;AACrC,oBAAc,SAAS,SAAS,SAAS,CAAC;AAAA,IAC3C,OAAO;AACN,oBAAc;AAAA,IACf;AAAA,EACD;AACD;AA1BU,IAAAA;AA8BV,SAAS,IAAI,GAAG,IAAI,YAAY,QAAQ,KAAK;AAC5C,QAAM,MAAM,YAAY,CAAC;AACzB,MAAI,QAAQ,MAAM;AACjB,UAAM,UAAU,YAAY,IAAI,CAAC;AACjC,QAAI,WAAW,WAAW,MAAM;AAC/B,aAAO;AAAA,IACR;AACA,gBAAY,OAAO,GAAG,CAAC;AACvB;AAEA,QAAI,CAAC,QAAQ,CAAC,aAAa;AAC1B,YAAM,gGAAgG;AAAA,IACvG;AAAA,EACD;AACD;AAEA,IAAI,OAAO,SAAS,YAAY,KAAK,WAAW,GAAG;AAClD,QAAM,6DAA6D;AACpE;AAEA,IAAI,SAAS;AACZ,UAAQ,IAAI,sBAAsB,sBAAsB,+BAA+B,eAAe;AACvG;AAGA,QAAQ;AAAA,EACP;AAAA,EACA;AAAA,EACA,YAAY;AACb,CAAC;AAED,SAAS,eAAeC,cAAuB;AAC9C,QAAM,UAAUA,aACd,IAAI,CAAC,QAAQ;AACb,UAAM,CAAC,QAAQ,GAAG,aAAa,IAAI,IAAI,MAAM,IAAI;AACjD,QAAI;AACJ,QAAI,cAAc,SAAS,GAAG;AAK7B,YAAM,WAAW,cACf,IAAI,CAAC,aAAa;AAGlB,cAAM,CAAC,UAAU,yBAAyB,gBAAgB,IAAI,SAAS,MAAM,IAAI;AAEjF,YAAI,SAAS,WAAW,GAAG;AAC1B,gBAAM,iCAAiC,qDAAqD;AAAA,QAC7F;AAEA,cAAM,YAAY,OAAO,qBAAqB;AAC9C,cAAM,SAAS,YAAY,mBAAmB;AAC9C,cAAM,gBAAgB,YAAY,0BAA0B;AAG5D,cAAM,YAAY,SAAS,MAAM,GAAG;AAEpC,YAAI;AACJ,mBAAW,QAAQ,WAAW;AAE7B,gBAAM,oBAAoB,KAAK,MAAM,GAAG;AAExC,gBAAM,cAAc,kBAClB,IAAI,CAAC,GAAG,UAAU;AAClB,gBAAI,QAAQ,KAAK,GAAG;AACnB,qBAAO;AAAA,YACR,OAAO;AACN,qBAAO,QAAQ,IAAI,CAAC;AAAA,YACrB;AAAA,UACD,CAAC,EACA,KAAK,EAAE;AAET,kBAAQ,QAAQ,IAAI,WAAW;AAC/B,cAAI,OAAO;AAEV;AAAA,UACD;AAAA,QACD;AACA,gBAAQ,SAAS;AACjB,YAAI,CAAC,aAAa,CAAC,OAAO;AACzB,gBAAM;AAAA,WACF,4EAA4E;AAAA,gEACvB;AAAA,4CACpB;AAAA,OACrC;AAAA,QACD;AAEA,eAAO,SAAS,UAAU;AAAA,MAC3B,CAAC,EACA,KAAK,EAAE;AACT,eAAS,SAAS;AAAA,IACnB,OAAO;AACN,eAAS;AAAA,IACV;AACA,QAAI,OAAO,WAAW,IAAI,GAAG;AAC5B,YAAM,aAAa,OAAO,MAAM,CAAC,EAAE,MAAM,GAAG;AAC5C,UAAI,WAAW,UAAU,GAAG;AAC3B,cAAM;AAAA;AAAA,MAEL;AAAA,MACF;AACA,YAAM,aAAa,WAAW,CAAC;AAC/B,YAAM,QAAQ,WAAW,CAAC;AAC1B,cAAQ,IAAI,UAAU,IAAI;AAC1B,aAAO;AAAA,IACR;AACA,WAAO;AAAA,EACR,CAAC,EACA,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;AACnB,SAAO;AACR;AAEA,SAAS,sBAAsBC,OAAgB;AAC9C,MAAI;AACJ,MAAI,oBAAgC,CAAC;AACrC,MAAI,SAAmB,CAAC;AACxB,WAAS,IAAI,GAAG,IAAIA,MAAK,QAAQ,KAAK;AACrC,UAAM,MAAMA,MAAK,CAAC;AAClB,QAAI,QAAQ,MAAM;AACjB,UAAI,CAAC,kBAAkB;AACtB,2BAAmB;AAAA,MACpB,OAAO;AACN,0BAAkB,KAAK,MAAM;AAAA,MAC9B;AACA,eAAS,CAAC;AAAA,IACX,OAAO;AACN,aAAO,KAAK,GAAG;AAAA,IAChB;AAAA,EACD;AAEA,MAAI,CAAC,kBAAkB;AACtB,uBAAmBA;AAAA,EACpB,OAAO;AACN,QAAI,OAAO,SAAS,GAAG;AAEtB,iBAAW,aAAa,QAAQ;AAC/B,yBAAiB,KAAK,SAAS;AAAA,MAChC;AACA,eAAS,CAAC;AAAA,IACX;AAAA,EACD;AAEA,QAAM,iBAAsD,CAAC;AAC7D,aAAW,OAAO,mBAAmB;AACpC,QAAI,IAAI,CAAC,GAAG;AACX,qBAAe,KAAK;AAAA,QACnB,SAAS,IAAI,CAAC;AAAA,QACd,MAAM,IAAI,MAAM,CAAC;AAAA,MAClB,CAAC;AAAA,IACF;AAAA,EACD;AAEA,SAAO,EAAC,kBAAkB,eAAc;AACzC;AAEA,IAAI,OAAO;AACV,QAAM,WAAW,sBAAsB,WAAW;AAIlD,QAAM,mBAAmB,eAAe,SAAS,gBAAgB;AACjE,MAAI;AACH,QAAI,SAAS;AACZ,cAAQ,IAAI,uBAAuB,WAAW,iBAAiB,KAAK,GAAG,GAAG;AAAA,IAC3E;AACA,iBAAa,SAAU,kBAAkB,EAAC,OAAO,UAAS,CAAC;AAC3D,QAAI,SAAS,eAAe,SAAS,GAAG;AACvC,UAAI,IAAI;AACR,iBAAW,iBAAiB,SAAS,gBAAgB;AACpD,cAAM,aAAa,eAAe,cAAc,QAAQ,CAAC,CAAC;AAC1D,YAAI,SAAS;AACZ,kBAAQ,IAAI,aAAa,eAAe,cAAc,WAAW,WAAW,KAAK,GAAG,GAAG;AAAA,QACxF;AACA,qBAAa,cAAc,SAAS,YAAY,EAAC,OAAO,UAAS,CAAC;AAClE;AAAA,MACD;AAAA,IACD;AAAA,EACD,SAAQ,GAAN;AAAA,EAAO;AACV,OAAO;AACN,MAAI;AACH,QAAI,SAAS;AACZ,cAAQ,IAAI,2BAA2B,WAAW,YAAY,KAAK,GAAG,GAAG;AAAA,IAC1E;AACA,iBAAa,SAAU,aAAa,EAAC,OAAO,UAAS,CAAC;AAAA,EACvD,SAAQ,GAAN;AAAA,EAAO;AACV;","names":["error","getGitBranch","commandArgs","args"]}