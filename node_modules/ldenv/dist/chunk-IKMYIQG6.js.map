{"version":3,"sources":["../src/index.ts","../src/utils.ts"],"sourcesContent":["/**\n * This module exposes a single function as default export\n *\n * @module dotenv-set\n */\n\nimport {parse as dotenvParse} from 'dotenv';\nimport {expand} from 'dotenv-expand';\nimport fs from 'node:fs';\nimport {lookupFile, lookupMultipleFiles} from './utils';\n\n/**\n * Configuration Options\n */\nexport type Config = {\n\t/** The mode will specify which file to load.\n\t * by default it will only load `.env` and `.env.local` with `.env.local` taking priority.\n\t *\n\t * If a specific mode is provided, it will load them in this order (latter one override the earlier ones):\n\t * - `.env`\n\t * - `.env.local`\n\t * - `.env.<mode>`\n\t * - `.env.<mode>.local`\n\t *\n\t * @remarks if `mode === 'local'` then it will just load `.env` and `env.local`\n\t */\n\tmode?: string;\n\t/** This let you specify the default mode if no mode are specified explicitly.\n\t * By default it is 'local' */\n\tdefaultMode?: string;\n\t/** This let you specify a specific folder to load the .env file from.\n\t * By default it use the current directory */\n\tfolder?: string;\n\t/** This let you specify the env variable it uses to detect the mode, if not specified in the options.\n\t * By default it take the mode from the env variable 'MODE'\n\t * It can also be a list of string and it will take the first one that is defined\n\t */\n\tuseModeEnv?: string | string[];\n\tdefaultEnvFile?: string;\n};\n\ntype ResolvedConfig = Config;\n\n/**\n * Uses [dotenv](https://github.com/motdotla/dotenv) and [dotenv-expand](https://github.com/motdotla/dotenv-expand) to load additional environment variables from the following files in your environment directory:\n *\n * ```\n * .env                # loaded in all cases\n * .env.local          # loaded in all cases, ignored by git\n * .env.[mode]         # only loaded in specified mode\n * .env.[mode].local   # only loaded in specified mode, ignored by git\n * ```\n *\n * @example\n * ```ts\n * import {loadEnv} from 'ldenv';\n * loadEnv();\n * ```\n * @example\n * ```ts\n * import {loadEnv} from 'ldenv';\n * loadEnv({mode: 'production'});\n * ```\n *\n * @param config - The configuration optiom\n * @returns The parsed env variable\n */\nexport function loadEnv(config?: Config): Record<string, string> {\n\tconst resolvedConfig: ResolvedConfig = {...config};\n\tlet {mode, folder, useModeEnv} = resolvedConfig;\n\n\tif (!folder) {\n\t\tfolder = process.env['ENV_ROOT_FOLDER'];\n\t\tif (!folder) {\n\t\t\ttry {\n\t\t\t\tconst parsed = dotenvParse(fs.readFileSync('.env', {encoding: 'utf-8'}));\n\t\t\t\tObject.entries(parsed).forEach(function ([key, value]) {\n\t\t\t\t\tif (key === 'ENV_ROOT_FOLDER') {\n\t\t\t\t\t\tfolder = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t\ttry {\n\t\t\t\tconst parsed2 = dotenvParse(fs.readFileSync('.env.local', {encoding: 'utf-8'}));\n\t\t\t\tObject.entries(parsed2).forEach(function ([key, value]) {\n\t\t\t\t\tif (key === 'ENV_ROOT_FOLDER') {\n\t\t\t\t\t\tfolder = value;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} catch {}\n\t\t\ttry {\n\t\t\t\tfolder = fs.readFileSync('.root.env', {encoding: 'utf-8'});\n\t\t\t} catch {}\n\t\t}\n\t}\n\n\tconst env_root = folder || '.';\n\n\tif (!useModeEnv) {\n\t\t// we first get the MODE_ENV name\n\t\t// we get from the environment if there else we get from the .env and .env.local\n\t\tlet mode_env_name = process.env['MODE_ENV'];\n\t\tif (!mode_env_name) {\n\t\t\ttry {\n\t\t\t\tconst content = lookupFile('.', ['.env'], {rootDir: env_root});\n\t\t\t\tif (content) {\n\t\t\t\t\tconst parsed = dotenvParse(content);\n\t\t\t\t\tObject.entries(parsed).forEach(function ([key, value]) {\n\t\t\t\t\t\tif (key === 'MODE_ENV') {\n\t\t\t\t\t\t\tmode_env_name = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch {}\n\t\t\ttry {\n\t\t\t\tconst content = lookupFile('.', ['.env.local'], {rootDir: env_root});\n\t\t\t\tif (content) {\n\t\t\t\t\tconst parsed = dotenvParse(content);\n\t\t\t\t\tObject.entries(parsed).forEach(function ([key, value]) {\n\t\t\t\t\t\tif (key === 'MODE_ENV') {\n\t\t\t\t\t\t\tmode_env_name = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} catch {}\n\t\t}\n\t\t// we fallback on MODE\n\t\tuseModeEnv = mode_env_name || 'MODE';\n\t}\n\n\tif (!mode) {\n\t\tif (typeof useModeEnv === 'string') {\n\t\t\tmode = process.env[useModeEnv];\n\t\t} else {\n\t\t\tfor (const variable of useModeEnv) {\n\t\t\t\tmode = process.env[variable];\n\t\t\t\tif (mode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!mode) {\n\t\tmode = config?.defaultMode || 'local';\n\t}\n\n\tconst env: Record<string, string> = {};\n\tconst envFiles = [/** default file */ `.env`, /** local file */ `.env.local`];\n\tif (config?.defaultEnvFile) {\n\t\tenvFiles.unshift(config.defaultEnvFile);\n\t}\n\tif (mode && mode !== 'local') {\n\t\tenvFiles.push(/** mode file */ `.env.${mode}`, /** mode local file */ `.env.${mode}.local`);\n\t}\n\n\tconst parsed = Object.fromEntries(\n\t\tenvFiles.flatMap((file) => {\n\t\t\tconst paths = lookupMultipleFiles('', [file], {\n\t\t\t\tpathOnly: true,\n\t\t\t\trootDir: env_root,\n\t\t\t});\n\t\t\tif (paths.length === 0) return [];\n\t\t\tconst result: [string, string][] = [];\n\t\t\t// we reverse the list as we want the first fetch (child) to take precedence\n\t\t\tfor (const path of paths.reverse()) {\n\t\t\t\tconst newEntries = Object.entries(dotenvParse(fs.readFileSync(path)));\n\t\t\t\tresult.push(...newEntries);\n\t\t\t}\n\t\t\treturn result;\n\t\t})\n\t);\n\n\t// let environment variables use each other and set them to process.env\n\texpand({parsed});\n\n\tfor (const [key, value] of Object.entries(parsed)) {\n\t\tenv[key] = value;\n\t}\n\n\tif (typeof useModeEnv === 'string') {\n\t\tprocess.env[useModeEnv] = mode;\n\t\tenv[useModeEnv] = mode;\n\t} else {\n\t\tfor (const v of useModeEnv) {\n\t\t\tprocess.env[v] = mode;\n\t\t\tenv[v] = mode;\n\t\t}\n\t}\n\n\t// return the resulting parsed env\n\treturn env;\n}\n","// taken from https://github.com/vitejs/vite/blob/63524bac878e8d3771d34ad7ad2e10cd16870ff4/packages/vite/src/node/utils.ts#L371-L400\nimport fs from 'node:fs';\nimport path from 'node:path';\n\ninterface LookupFileOptions {\n\tpathOnly?: boolean;\n\trootDir?: string;\n\tpredicate?: (file: string) => boolean;\n}\n\nexport function lookupFile(dir: string, formats: string[], options?: LookupFileOptions): string | undefined {\n\tconst dirFullPath = path.resolve(dir);\n\tfor (const format of formats) {\n\t\tconst fullPath = path.join(dir, format);\n\t\tif (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {\n\t\t\tconst result = options?.pathOnly ? fullPath : fs.readFileSync(fullPath, 'utf-8');\n\t\t\tif (!options?.predicate || options.predicate(result)) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\tconst parentDir = path.dirname(dirFullPath);\n\tconst absoluteRootDir = options?.rootDir ? path.resolve(options.rootDir) : undefined;\n\tif (parentDir !== dir && (!absoluteRootDir || parentDir.startsWith(absoluteRootDir))) {\n\t\treturn lookupFile(parentDir, formats, options);\n\t}\n}\n\nfunction _lookupMultipleFiles(dir: string, formats: string[], files: string[], options?: LookupFileOptions): void {\n\tconst dirFullPath = path.resolve(dir);\n\tfor (const format of formats) {\n\t\tconst fullPath = path.join(dir, format);\n\t\tif (fs.existsSync(fullPath) && fs.statSync(fullPath).isFile()) {\n\t\t\tconst result = options?.pathOnly ? fullPath : fs.readFileSync(fullPath, 'utf-8');\n\t\t\tif (!options?.predicate || options.predicate(result)) {\n\t\t\t\tfiles.push(result);\n\t\t\t}\n\t\t}\n\t}\n\tconst parentDir = path.dirname(dirFullPath);\n\tconst absoluteRootDir = options?.rootDir ? path.resolve(options.rootDir) : undefined;\n\tif (parentDir !== dir && (!absoluteRootDir || parentDir.startsWith(absoluteRootDir))) {\n\t\t_lookupMultipleFiles(parentDir, formats, files, options);\n\t}\n}\n\nexport function lookupMultipleFiles(dir: string, formats: string[], options?: LookupFileOptions): string[] {\n\tconst files: string[] = [];\n\t_lookupMultipleFiles(dir, formats, files, options);\n\treturn files;\n}\n"],"mappings":"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","names":["fs","parsed","fs","path"]}